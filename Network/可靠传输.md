为了实现可靠性传输，需要考虑很多事情，例如数据的破坏、丢包、重复以及分片顺序混乱等问题。TCP 是通过序列号、确认应答、重发控制、连接管理以及窗⼝控制等机制实现可靠性传输的。

对每个连接，TCP管理4个不同的定时器:

+ 重传定时器使用于当希望收到另一端的确认。在本章我们将详细讨论这个定时器以及一些相关的问题，如拥塞避免。
+ 坚持(persist)定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口
+ 保活(keepalive)定时器可检测到一个空闲连接的另一端何时崩溃或重启
+ 2MSL定时器测量一个连接处于TIME_WAIT状态的时间。

#### 重传机制

TCP 实现可靠传输的⽅式之⼀，是通过序列号与确认应答，在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回⼀个确认应答消息，表示已收到消息。在错综复杂的⽹络，并不⼀定能如上图那么顺利能正常的数据传输，数据在传输过程中可能丢失，针对数据包丢失的情况，会用重传机制来解决。常见的重传机制有：超时重传、快速重传、SACK、D-SACK

##### 超时重传

重传机制的其中⼀个⽅式，就是在发送数据时，设定⼀个定时器，当超过指定的时间后，没有收到对⽅ 的 ACK 确认应答报⽂，就会重发该数据，也就是我们常说的超时重传。TCP会在数据包丢失或、确认应答丢失的情况进行超时重传

![超时重传](..\image\超时重传.png)

RTT(Round-Trip Time 往返时延)：RTT 就是数据从⽹络⼀端传送到另⼀端所需的时间，也就是包的往返时间

超时重传时间是以 RTO （Retransmission Timeout 超时重传时间）表示。

+ 当超时时间 RTO 较⼤时，重发就慢，丢了⽼半天才重发，没有效率，性能差
+  当超时时间 RTO 较⼩时，会导致可能并没有丢就重发，于是重发的就快，会增加⽹络拥塞，导致 更多的超时，更多的超时导致更多的重发。

为了让重传机制更⾼效，超时重传时间 RTO 的值应该略⼤于报⽂往返 RTT 的值。

```
在发送端发包时记下 t0 ，然后接收端再把这个 ack 回来时再记⼀个 t1 ，于是 RTT = t1– t0 。没那么简单，这只是⼀个采样，不能代表普遍情况。实际上「报⽂往返 RTT 的值」是经常变化的，因为我们的⽹络也是时常变化的。也就因为「报⽂往返
RTT 的值」 是经常波动变化的，所以「超时᯿传时间 RTO 的值」应该是⼀个动态变化的值。
```

如果超时重发的数据，再次超时的时候，⼜需要重传的时候，TCP 的策略是超时时间隔加倍。 也就是每当遇到⼀次超时重传的时候，都会将下⼀次超时时间间隔设为先前值的两倍。两次超时，就说 明⽹络环境差，不宜频繁反复发送。 超时触发重传存在的问题是，超时周期可能相对较⻓。那是不是可以有更快的⽅式呢？ 于是就可以⽤「快速重传」机制来解决超时重发的时间等待

##### 快速重传

快速重传（Fast Retransmit）机制，它不以时间为驱动，⽽是以数据驱动重传。快速重传的机制是：接收方收到一个失序的报文段后就立刻发出重复确认，而不要等待自己发送数据时才进行捎带确认，当接收方没收到相应的包时，接收方会重复发送丢包前的ACK，当发送方连续收到3个相同的ACK，就知道发生丢包了（无需等待重传记时器到期），根据ACK序号就能重发丢的包。

```
例如当接收方成功的接受了发送方发送来的M1、M2并且分别给发送了ACK，现在接收方没有收到M3，而接收到了M4，显然接收方不能确认M4，因为M4是失序的报文段。如果根据可靠性传输原理接收方什么都不做，但是按照快速重传算法，在收到M4、M5等报文段的时候，不断重复的向发送方发送M2的ACK。该重复的ACK的目的在于让对方知道收到一个失序的报文段，并告诉对方自己希望收到的序号告诉对方我要M3啊，你快点发给我。如果接收方一连收到三个重复的ACK,那么发送方不必等待重传计时器到期，由于发送方尽早重传未被确认的报文段。
```

![快速重传](..\image\快速重传.png)

+ 第⼀份 Seq1 先送到了，于是就 Ack 回 2；
+ 结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；
+ 后⾯的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；
+ 发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失
  的 Seq2。
+ 最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。

快速重传的⼯作⽅式是当收到三个相同的 ACK 报⽂时，会在定时器过期之前，重传丢失的报⽂ 段。 快速重传机制只解决了⼀个问题，就是超时时间的问题，但是它依然⾯临着另外⼀个问题。就是重传的 时候，是重传之前的⼀个，还是重传所有的问题。 ⽐如对于上⾯的例⼦，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。不清楚丢失包后面传送的数据是否有成功的送到

##### SACK

SACK (Selective Acknowledgment 选择性确认)，这种⽅式需要在 TCP 头部「选项」字段⾥加⼀个 SACK 的东⻄，它可以将缓存的地图发送给发送⽅，这样发送⽅就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。发送⽅收到了三次同样的 ACK 确认报⽂，于是就会触发快速重发机制，通过 SACK 信息发现 只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进⾏重复。

![SACK](..\image\SACK.png)

如果要⽀持 SACK ，必须双⽅都要⽀持。在 Linux 下，可以通过 net.ipv4.tcp_sack 参数打开这个功 能（Linux 2.4 后默认打开）

##### Duplicate SACK

Duplicate SACK ⼜称 D-SACK ，其主要使⽤了 SACK 来告诉「发送⽅」有哪些数据被重复接收了。使用D-SACK的好处有（在 Linux 下可以通过 net.ipv4.tcp_dsack 参数开启/关闭这个功能（Linux 2.4 后默认打开））：

1. 可以让「发送⽅」知道，是发出去的包丢了，还是接收⽅回应的 ACK 包丢了; 
2. 可以知道是不是「发送⽅」的数据包被⽹络延迟了;
3. 可以知道⽹络中是不是把「发送⽅」的数据包给复制了

+ ACK 丢包

  ![SACK](..\image\SACK.png)

  + 「接收⽅」发给「发送⽅」的两个 ACK 确认应答都丢失了，所以发送⽅超时后，᯿传第⼀个数据包（3000 ~ 3499）
  + 于是「接收⽅」发现数据是重复收到的，于是回了⼀个 SACK = 3000~3500，告诉「发送⽅」3000~3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 D-SACK 。
  + 这样「发送⽅」就知道了，数据没有丢，是「接收⽅」的 ACK 确认报⽂丢了。

#### 滑动窗口

TCP 是每发送⼀个数据，都要进⾏⼀次确认应答。当上⼀个数据包收到了应答了， 再发送 下⼀个。这样的传输⽅式有⼀个缺点：数据包的往返时间越⻓，通信的效率就越低。为解决这个问题，TCP 引⼊了窗⼝这个概念。即使在往返时间较⻓的情况下，它也不会降低⽹络通信的 效率。 那么有了窗⼝，就可以指定窗⼝⼤⼩，窗⼝⼤⼩就是指⽆需等待确认应答，⽽可以继续发送数据的最⼤值。窗⼝的实现实际上是操作系统开辟的⼀个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

假设窗⼝⼤⼩为 3 个 TCP 段，那么发送⽅就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢 失，可以通过「下⼀个确认应答进⾏确认」。如下图：

![滑动窗口](..\image\滑动窗口.png)

图中的 ACK 600 确认应答报⽂丢失，也没关系，因为可以通过下⼀个确认应答进⾏确认，只要发送⽅ 收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收⽅」都收到了。这个模式就叫累计确 认或者累计应答。

通常窗⼝的⼤⼩是由接收⽅的窗⼝⼤⼩来决定的。是接收端告诉发送端⾃⼰还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的 处理能⼒来发送数据，⽽不会导致接收端处理不过来。发送⽅发送的数据⼤⼩不能超过接收⽅的窗⼝⼤⼩，否则接收⽅就⽆法正常接收到数据。

##### 发送方窗口

TCP 滑动窗⼝⽅案使⽤三个指针来跟踪在四个传输类别中的每⼀个类别中的字节。其中两个指针是绝对 指针（指特定的序列号），⼀个是相对指针（需要做偏移）

![发送窗口](..\image\发送窗口.png)

+ #1 是已发送并收到 ACK确认的数据：1~31 字节
+  #2 是已发送但未收到 ACK确认的数据：32~45 字节
+ #3 是未发送但总⼤⼩在接收⽅处理范围内（接收⽅还有空间）：46~51字节
+ #4 是未发送但总⼤⼩超过接收⽅处理范围（接收⽅没有空间）：52字节以后



+ SND.WND ：表示发送窗⼝的⼤⼩（⼤⼩是由接收⽅指定的）
+ SND.UNA ：是⼀个绝对指针，它指向的是已发送但未收到确认的第⼀个字节的序列号，也就是 #2 的第⼀个字节
+ SND.NXT ：也是⼀个绝对指针，它指向未发送但可发送范围的第⼀个字节的序列号，也就是 #3 的 第⼀个字节
+ 指向 #4 的第⼀个字节是个相对指针，它需要 SND.UNA 指针加上 SND.WND ⼤⼩的偏移量，就可以 指向 #4 的第⼀个字节了。

> 可⽤窗⼝⼤ = SND.WND -（SND.NXT - SND.UNA）

##### 接收方窗口

![接收窗口](..\image\接收窗口.png)

+ \#1 + #2 是已成功接收并确认的数据（等待应⽤进程读取）
+ #3 是未收到数据但可以接收的数据
+  #4 未收到数据并不可以接收的数据；
+ RCV.WND ：表示接收窗⼝的⼤⼩，它会通告给发送⽅。
+ RCV.NXT ：是⼀个指针，它指向期望从发送⽅发送来的下⼀个数据字节的序列号，也就是 #3 的第 ⼀个字节
+  指向 #4 的第⼀个字节是个相对指针，它需要 RCV.NXT 指针加上 RCV.WND ⼤⼩的偏移量，就可以 指向 #4 的第⼀个字节了。

接收窗⼝的⼤⼩是约等于发送窗⼝的⼤⼩的。 因为滑动窗⼝并不是⼀成不变的。⽐如，当接收⽅的应⽤进程读取数据的速度⾮常快的话，这样的话接 收窗⼝可以很快的就空缺出来。那么新的接收窗⼝⼤⼩，是通过 TCP 报⽂中的 Windows 字段来告诉发 送⽅。那么这个传输过程是存在时延的，所以接收窗⼝和发送窗⼝是约等于的关系。

#### 流量控制

​		TCP 提供⼀种机制可以让「发送⽅」根据「接收⽅」的实际接收能⼒控制发送 的数据量，这就是所谓的流量控制。通过让接收⽅指明希望从发送⽅接收的数据⼤⼩（窗⼝⼤⼩）来进⾏流量控 制。 如果窗⼝⼤⼩为 0 时，就会阻⽌发送⽅给接收⽅传递数据，直到窗⼝变为⾮ 0 为⽌，这就是窗⼝关闭。接收⽅向发送⽅通告窗⼝⼤⼩时，是通过 ACK 报⽂来通告的。当发⽣窗⼝关闭时，接收⽅处理完数据后，会向发送⽅通告⼀个窗⼝⾮ 0 的 ACK 报⽂，如果这个通告窗⼝的 ACK 报⽂在⽹络中丢失了，这会导致发送⽅⼀直等待接收⽅的⾮ 0 窗⼝通知，接收⽅也⼀直等待发送⽅的数据，如不采取措施，这 种相互等待的过程，会造成了死锁的现象。

​		为了解决这个问题，TCP 为每个连接设有⼀个持续定时器，只要 TCP 连接⼀⽅收到对⽅的零窗⼝通 知，就启动持续计时器。 如果持续计时器超时，就会发送窗⼝探测 ( Window probe ) 报⽂，⽽对⽅在确认这个探测报⽂时，给出⾃⼰现在的接收窗⼝⼤⼩。

+ 如果接收窗⼝仍然为 0，那么收到这个报⽂的⼀⽅就会重新启动持续计时器
+ 如果接收窗⼝不是 0，那么死锁的局⾯就可以被打破了

窗⼝探测的次数⼀般为 3 次，每次⼤约 30-60 秒（不同的实现可能会不⼀样）。如果 3 次过后接收窗 ⼝还是 0 的话，有的 TCP 实现就会发 RST 报⽂来中断连接。

#####  糊涂窗⼝综合症

​		如果接收⽅太忙了，来不及取⾛接收窗⼝⾥的数据，那么就会导致发送⽅的发送窗⼝越来越⼩。 到最后，如果接收⽅腾出⼏个字节并告诉发送⽅现在有⼏个字节的窗⼝，⽽发送⽅会义⽆反顾地发送这 ⼏个字节，这就是糊涂窗⼝综合症。TCP + IP 头有 40 个字节，为了传输那⼏个字节的数据，要达上这么⼤的开销，这 太不经济了。

​		糊涂窗⼝综合症的现象是可以发⽣在发送⽅和接收⽅：接收⽅可以通告⼀个⼩的窗⼝,⽽发送⽅可以发送⼩数据

+ 让接收⽅不通告⼩窗⼝给发送⽅：当「窗⼝⼤⼩」⼩于 min( MSS，缓存空间/2 ) ，也就是⼩于 MSS 与 1/2 缓存⼤⼩中的最⼩值时，就会 向发送⽅通告窗⼝为 0 ，也就阻⽌了发送⽅再发数据过来。等到接收⽅处理了⼀些数据后，窗⼝⼤⼩ >= MSS，或者接收⽅缓存空间有⼀半可以使⽤，就可以把窗 ⼝打开让发送⽅发送数据过来。
+ 让发送⽅避免发送⼩数据：使⽤ Nagle 算法，该算法的思路是延时处理，它满⾜以下两个条件中的⼀条才可以发送数据：要等到窗⼝⼤⼩ >= MSS 或是 数据⼤⼩ >= MSS、收到之前发送数据的 ack 回包

#### 拥塞控制

​		流量控制是避免「发送⽅」的数据填满「接收⽅」的缓存，计算机⽹络都处在⼀个共享的环境。因此也有可能会因为其他主机之间的通信使得⽹络拥 堵。 在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传 数据，但是⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进 ⼊恶性循环被不断地放⼤.当⽹络发送拥塞时，TCP 会⾃我 牺牲，降低发送的数据量。

​		拥塞控制，控制的⽬的就是避免**「发送方」**的数据填满整个⽹络。为了在「发送⽅」调节所要发送数据的量，定义了⼀个叫做「拥塞窗⼝」的概念。拥塞窗口cwnd是发送⽅维护的⼀个的状态变量，它会根据⽹络的拥塞程度动态变化的。发送窗口 swnd 和接收窗⼝ rwnd 是约等于的关系，那么由于加⼊了拥塞窗⼝的概 念后，此时发送窗⼝的值是swnd = min(cwnd, rwnd)，也就是拥塞窗⼝和接收窗⼝中的最⼩值。拥塞窗⼝ cwnd 变化的规则如下

+ 只要⽹络中没有出现拥塞， cwnd 就会增⼤
+ 但⽹络中出现了拥塞， cwnd 就减少，只要「发送⽅」没有在规定时间内接收到 ACK 应答报⽂，也就是发⽣了超时重传，就会认为⽹络 出现了⽤拥塞。

拥塞控制算法：慢启动、拥塞控制、拥塞发生、快速恢复

##### 慢启动

TCP 在刚建⽴连接完成后，⾸先是有个慢启动的过程，这个慢启动的意思就是⼀点⼀点的提⾼发送数据 包的数量：当发送⽅每收到⼀个 ACK，拥塞窗⼝ cwnd 的⼤⼩就会加 1......假定拥塞窗⼝ cwnd 和发送窗⼝ swnd 相等

+ 连接建⽴完成后，⼀开始初始化 cwnd = 1 ，表示可以传⼀个 MSS ⼤⼩的数据。 
+ 当收到⼀个 ACK 确认应答后，cwnd 增加 1，于是⼀次能够发送 2 个
+  当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以⽐之前多发2 个，所以这⼀次能够发送 4 个 
+ 当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以⽐ 之前多发 4 个，所以这⼀次能够发送 8 个。

![慢启动](..\image\慢启动.png)

慢启动算法，发包的个数是指数性的增⻓,当慢启动cwnd到达慢启动⻔限 ssthresh （slow start threshold）时会采用"拥塞避免算法"

+ 当 cwnd < ssthresh 时，使⽤慢启动算法
+ 当 cwnd >= ssthresh 时，就会使⽤「拥塞避免算法」

##### 拥塞避免

当拥塞窗⼝ cwnd 「超过」慢启动⻔限 ssthresh 就会进⼊拥塞避免算法。⼀般来说 ssthresh 的⼤⼩是 65535 字节，拥塞避免算法后，它的规则是：每当收到⼀个 ACK 时，cwnd 增加 1/cwnd......假定 ssthresh 为 8

+ 当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd ⼀共增加 1，于是这⼀次 能够发送 9 个 MSS ⼤⼩的数据，变成了线性增⻓。

![拥塞避免](..\image\拥塞避免.png)

拥塞避免算法就是将原本慢启动算法的指数增⻓变成了线性增⻓，还是增⻓阶 段，但是增⻓速度缓慢了⼀些。 就这么⼀直增⻓着后，⽹络就会慢慢进⼊了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失 的数据包进⾏重传。 当触发了重传机制，也就进⼊了「拥塞发⽣算法」。

##### 拥塞发生

当⽹络出现拥塞，也就是会发⽣数据包重传，重传机制主要有两种：超时重传、快速重传

+ 发⽣超时重传的拥塞发⽣算法：ssthresh 设为 cwnd/2 ，cwnd 重置为 1，接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是⼀旦「超时重传」，⻢上回到解放 前。但是这种⽅式太激进了，反应也很强烈，会造成⽹络卡顿

  ![拥塞发生-超时重传](..\image\拥塞发生-超时重传.png)

+ 发生快速重传的拥塞发⽣算法：当接收⽅发现丢了⼀个中间包的时候，发送三次前 ⼀个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。 TCP 认为这种情况不严重，因为⼤部分没丢，只丢了⼀⼩部分。cwnd = cwnd/2 ，也就是设置为原来的⼀半; ssthresh = cwnd ; 进⼊快速恢复算法

##### 快速恢复

快速重传和快速恢复算法⼀般同时使⽤，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明⽹络也 不那么糟糕，所以没有必要像 RTO 超时那么强烈。进⼊快速恢复之前， cwnd 和 ssthresh 已被更新了：cwnd = cwnd/2 ，也就是设置为原来的⼀半; ssthresh = cwnd ......进入快速恢复算法如下：

+ 拥塞窗⼝ cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）； 

+ 重传丢失的数据包

+ 如果再收到重复的 ACK，那么 cwnd 增加 1

+  如果收到新数据的 ACK 后，把cwnd设置为第⼀步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的 状态了，也即再次进⼊拥塞避免状态；

  ![快速恢复](..\image\快速恢复.png)