### HTTP

​		http是基于客户端/服务端的架构模型，是一个无状态的超文本传输协议（这样不需要先前的信息，能够更快应答，需要某种机制识别用户，这种机制就是Session），同一个客户端的这次请求和上次请求是没有对应关系。HTTP协议永远都是客户端发起请求，服务器回送响应。HTTP是一个基于TCP/IP协议簇来传递数据，传输层使用到协议为TCP协议，而网络层使用的是IP协议。HTTP建立连接的过程也就是建立TCP连接的过程（三次是最少的安全次数，两次不安全，四次浪费资源）

> HTTP 是⼀个在计算机世界⾥专⻔在「两点」之间「传输」⽂字、图⽚、⾳频、视频等「超⽂本」数据 的「约定和规范」。

![TCP-IP基础层次图](..\image\TCP-IP基础层次图.png)

#### http请求

![http请求报文](..\image\http请求报文.png)

##### 请求行

请求方法、请求url、http协议及版本

+ 请求方法：HTTP 1.0包括三种请求方法(GET、HEAD、POST)，HTTP 1.1中新增了五种请求方法(OPTIONS、PUT、DELETE、TRACE、CONNECT)

  + GET：请求指定的页面信息，并返回实体主体，请求参数和对应的值附加在URL后面，大小受限(最大不超过1024)，不适合传递私密数据
  + POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）请求的参数封装在了HTTP请求的请求体中,以名称/值的形式出现,可以传输大量的数据.POST请求一般用于表单数据的提交中

  > 1. 从`参数`的传递方面来看,GET请求的参数是直接拼接在地址栏URL的后面,而POST请求的参数是放到请求体里面的，GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
  >
  > 2. 从`长度限制`方面来看,GET请求有具体的长度(chrome
  >
  >    URL最大长度限制为8182个字符，而POST理论上没有,但是浏览器一般都有一个界限（Tomcat对POST大小的限制默认2M）
  >
  > 3. 从`安全`方面来看,GET请求相较于POST,因为数据都是明文显示在URL上面的,所以安全和私密性不如POST
  >
  > 4. 从`本质`上来说,GET和POST都是TCP连接,并无实质的区别.但是由于HTTP/浏览器的限定,导致它们在应用过程中体现出了一些不同.GET产生一个TCP数据包,POST产生两个TCP数据包。对于GET请求,浏览器会把http header 和 data 一并发出去,服务器响应200(返回数据)；而对于POST,浏览器先发送header,服务器响应100 continue,浏览器再发送data,服务器响应200 ok
  >
  >    据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。
  >    并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

  + HEAD：类似于GET请求，只不过返回的响应体中没有具体内容，用于获取请求头
  + OPTIONS：允许客户端查看服务器的性能
  + PUT： 从客户端向服务器传送的数据取代指定的文档的内容；
  + DELETE：请求服务器删除指定的页面；
  + TRACE：回显服务器收到的请求，主要用于测试或诊断；
  + CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。

+ 请求url：请求对应的url地址，它与请求头的host属性组成完整的请求url
+ http版本：协议名称以及版本号

##### 请求头

+ host的值为客户端请求的服务器的域名（或者ip）和端口，当单台服务器设置多个虚拟主机(a.com、b.com)时，DNS解析出的IP地址会指向同一台主机，此时可以通过客户端请求头的host信息判断访问的是服务器上对应的虚拟主机

  > HTTP/1.1 的所有请求报文中必须包含一个Host头字段。如果一个 HTTP/1.1 请求缺少 Host 头字段或者设置了超过一个的 Host 头字段，一个400（Bad Request）状态码会被返回

+ referer告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理，例如服务器能够从HTTP Referer中识别访问来源，可以进行访问统计、日志记录、缓存优化等。在以下两种情况下，`Referer` 不会被发送：

  - 来源页面采用的协议为表示本地文件的 "file" 或者 "data" URI；
  - 当前请求页面采用的是非安全协议，而来源页面采用的是安全协议（HTTPS）
  - 直接输入网址或通过浏览器书签访问

+ Origin 指示了请求来自于哪个站点。该字段仅指示服务器名称，并不包含任何路径信息。该首部用于 CORS 请求或者 POST 请求。除了不包含路径信息，该字段与 Referer 首部字段相似

  + 只有跨域请求，或者同域时发送post请求，才会携带origin请求头，而referer不论何种情况下，只要浏览器能获取到请求源都会携带，除了上面提到的几种情况
  + origin的值只包括协议、域名和端口，而rerferer不但包括协议、域名、端口还包括路径，参数，注意不包括hash值

+ Content-Type：发送端发送的实体数据的数据类型，告诉服务端此HTTP请求提交的内容类型。一般只有post提交时才需要设置该属性

+ Connection：允许客户端和服务器指定与请求/响应连接有关的选项，例如这是为Keep-Alive则表示保持连接

+ User-Agent：发送请求的浏览器类型、操作系统等信息

+ Accept：客户端可识别的内容类型列表，用于指定客户端接收那些类型的信息

+ Accept-Encoding：客户端可识别的数据编码

+ Accept-Language：表示浏览器所支持的语言类型

| 常见字段          | 说明                                                        | 示例                                                         |
| ----------------- | ----------------------------------------------------------- | ------------------------------------------------------------ |
| Accept            | 可接收的响应内容类型                                        | Accept:text/plain (文本类型)                                 |
| Accept-Charset    | 可接收的字符集                                              | Accept-Charset: utf-8                                        |
| Accept-Encoding   | 可接受的响应内容的编码方式                                  | Accept-Encoding: gzip, deflate                               |
| Accept-Language   | 可接受的响应内容语言列表                                    | Accept-Language: en-US                                       |
| Accept-Datetime   | 可接受的按照时间来表示的响应内容版本                        | Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT               |
| Authorization     | HTTP协议中需要认证资源的认证信息                            | Authorization: Basic OSdjJGRpbjpvcGVuIANlc2SdDE==            |
| Cache-Control     | 请求/回复中的,是否使用缓存机制                              | Cache-Control: no-cache                                      |
| Connection        | 客户端想要优先使用的连接类型                                | Connection: keep-alive Connection: Upgrade——如果是close则需要建立进行TCP四次挥手关闭连接，如果是keep-alive则表示为长连接 |
| Content-Length    | 以8进制表示的请求体的长度                                   | Content-Length: 348                                          |
| Content-Type      | 请求体的MIME类型                                            | Content-Type: application/x-www-form-urlencoded              |
| Date              | 发送该消息的日期和时间                                      | Date: Dec, 26 Dec 2015 17:30:00 GMT                          |
| Expect            | 表示客户端要求服务器做出特定的行为                          | Expect: 100-continue                                         |
| From              | 发起此请求的用户的邮件地址                                  | From: [user@itbilu.com](mailto:user@itbilu.com)              |
| Host              | 服务器域名和端口号,默认端口可省略                           | Host: [www.itbilu.com:80](http://www.itbilu.com/) or [www.itbilu.com](http://www.itbilu.com/) |
| If-Match          | 主要用于PUT,实体匹配才可以操作                              | If-Match: "9jd00cdj34pss9ejqiw39d82f20d0ikd"                 |
| If-Modified-Since | 资源未被修改的情况下返回304未修改                           | If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT             |
| User-Agent        | 浏览器的身份标识字符串:发送请求的浏览器类型、操作系统等信息 | User-Agent: Mozilla/                                         |
| Upgrade           | 要求服务器升级到一个高版本协议                              | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11               |
| Via               | 告诉服务器,这个请求是由哪个代理发出的                       | Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1)               |
| Referer           | 表示跳转到当前页面的之前的页面                              | Referer: http://itbilu.com/nodejs                            |
| Origin            | 发起一个针对跨域资源共享的请求                              | Origin: [http://www.itbilu.com](http://www.itbilu.com/)      |

##### 空行

表示请求体开始

##### 请求体(数据)

承载请求参数，以键值对的形式将参数编码成一个格式化的字符串。请求体不在 GET 方法中使用，而是在POST 方法中使用。POST 方法适用于需要客户填写表单的场合。与请求包体相关的最常使用的是包体类型 Content-Type 和包体长度 Content-Length

#### http响应

![http响应报文](..\image\http响应报文.png)

##### 状态行

HTTP协议版本、状态码、状态码描述(一般不显示)

![HTTP状态码](..\image\HTTP状态码.png)

+ 1xx：提示信息，是协议处理中的⼀种中间状态，实际⽤到的⽐较少
+ 2xx：成果，表示服务器成功处理了客户端的请求
  + 「200 OK」是最常⻅的成功状态码，表示⼀切正常。如果是⾮ HEAD 请求，服务器返回的响应头都会 有 body 数据
  + 「204 No Content」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据
  + 「206 Partial Content」是应⽤于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源 的全部，⽽是其中的⼀部分，也是服务器处理成功的状态
+ 3xx：重定向，表示客户端请求的资源发送了变动，需要客户端⽤新的 URL 重新发送请求获取资源，也就是重定向
  + 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次 访问
  
  + 「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。 301 和 302 都会在响应头⾥使⽤字段 Location ，指明后续要跳转的 URL，浏览器会⾃动重定向新的 URL
  
  + 「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲⽂件，也称缓存重定 向，⽤于缓存控制。表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，条件不满足。返回304时，不包含任何响应主体。虽然304被划分在3XX，但和重定向一毛钱关系都没有
  
    ```
    一个304的使用场景：
    缓存服务器向服务器请求某一个资源的时候，服务器返回的响应报文具有这样的字段：Last-Modified:Wed,7 Sep 2011 09:23:24，缓存器会保存这个资源的同时，保存它的最后修改时间。下次用户向缓存器请求这个资源的时候，缓存器需要确定这个资源是新的，那么它会向原始服务器发送一个HTTP请求（GET方法），并在请求头部中包含了一个字段：If-Modified-Since:Wed,7 Sep 2011 09:23:24，这个值就是上次服务器发送的响应报文中的最后修改时间。假设这个资源没有被修改，那么服务器返回一个响应报文：用304告诉缓存器资源没有被修改，并且响应体是空的，不会浪费带宽。
    
    HTTP/1.1 304 Not Modified
    Date：Sat, 15 Oct 2011 15:39:29
    (空行)                                      
    (空响应体)
    ```
+ 4xx：客户端有误，表示客户端发送的报⽂有误，服务器⽆法处理，也就是错误码的含义
  
  + 「400 Bad Request」表示客户端请求的报⽂有错误，客户端请求有语法错误，服务器无法理解，但只是个笼统的错误
  + 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。
  + 「403 Forbidden」表示服务器禁⽌访问资源，服务器收到请求，但是拒绝提供服务，并不是客户端的请求出错
  + 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端（比如，输入了错误的url）
  + 415 Unsupported media type：不支持的媒体类型
+ 5xx：服务端有误，表示客户端请求报⽂正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码
  
  + 「500 Internal Server Error」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并 不知道
  + 「501 Not Implemented」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思
  + 「502 Bad Gateway」通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器发⽣了错误
  + 「503 Service Unavailable」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍 后重试”的意思。

##### 响应头

+ Cache-Control：响应输出到客户端后,服务端通过该属性告诉客户端该怎么控制响应内容的缓存
+ ETag：表示你请求资源的版本,如果该资源发生啦变化,那么这个属性也会跟着变
+ Location：在重定向中或者创建新资源时使用
+ Set-Cookie：服务端可以设置客户端的cookie

##### 空行

##### 响应数据

#### 幂等

在 HTTP 协议⾥，所谓的「安全」是指请求⽅法不会「破坏」服务器上的资源。 所谓的「幂等」，意思是多次执⾏相同的操作，结果都是「相同」的。GET ⽅法就是安全且幂等的，因为它是「只读」操作，⽆论操作多少次，服务器上的数据 都是安全的，且每次的结果都是相同的。 POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据 就会创建多个资源，所以不是幂等的。

#### 版本区别

影响一个HTTP网络请求的因素主要有两个：带宽和延迟

+ 带宽：现在网络基础建设已经使得带宽得到极大的提升，一般不用考虑带宽会影响网速
+ 延迟
  + 浏览器阻塞：不同浏览器支持的并发连接个数各不相同且有限制，通常为4个，超过浏览器最大连接数限制，后续请求就会被阻塞。
  + DNS查询：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。
  + 连接建立：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。

##### HTTP 0.9

仅支持GET请求方式，没有在通信中制定版本号且不支持请求头，由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。

##### HTTP 1.0

+ 支持POST、GET、HEAD三种方法
+ 添加请求头和响应头的概念
+ 一次请求建议一次TCP连接，请求完就断开：规定浏览器与服务器之间只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求，下一个请求需要再次建立TCP连接，即不支持keepalive。想要实现长连接，需要添加请求头 Connection: Keep-Alive
+ HTTP 1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名，在建立TCP连接的时候就指定了IP地址，默认一个IP地址只对应一个主机名，IP地址上只有一个host
+ 只有16个状态码，对错误或警告的提示不够具体

##### HTTP 1.1

+ 支持POST、GET、HEAD、PUT、DELETE、CONNECT、TRACE、OPTIONS八种方法。
+ **支持持久连接(默认)**，TCP连接默认不关闭，可以被多个请求复用，一个TCP连接可以允许多个HTTP请求，减少了建立和关闭连接的消耗和延迟
+ **加入管道机制**，在同一个TCP连接里w，允许多个请求同时发送，增加了并发性，进一步改善了HTTP协议的效率；举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。
+ 请求头新增Host域，实现一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点，即web server上的多个虚拟站点可以共享同一个ip和端口。
+ 请求头新增range域，允许只请求资源的某个部分（返回码为206），可以充分利用宽带和连接
+ 新增了24个状态响应码。HTTP/1.1加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码 401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。
+ 相对于HTTP 1.0引入了一个Warning头域，增加对错误或警告信息的描述
+ 缓存处理：当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求。通过设置字段cache-control来控制缓存。
+ 断点传输：在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率

##### HTTP 2.0

HTTP2.0，下一代的HTTP协议。相比于HTTP1.x，大幅度的提升了web性能，进一步减少了网络延时和拥塞。

+ 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

+ 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。（降低了延迟同时提高了带宽的利用率）

+ header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

+ 服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。目前，有大多数网站已经启用HTTP2.0，例如YouTuBe，淘宝网等网站，利用chrome控制台可以查看是否启用H2。

##### HTTP 3.0



### HTTPS

HTTP 协议⾥有优缺点⼀体的双刃剑，分别是「⽆状态、明⽂传输」，同时还有⼀⼤缺点「不安全」

http的安全性问题

+ 使用明文进行通信，内容可能会被窃听
+ 不验证通信方的身份，通信方的身份有可能遭遇伪装
+ 无法证明报文的完整性，报文有可能遭篡改。

对称加密：加密和解密使用同一密钥（运算速度快，但密钥容易被窃取）

非对称加密：使用一对密钥进行加密和解密。公开密钥所有人都可以获得，公钥可以解析私钥加密的内容，私钥也可以解析公钥加密的内容（安全性高，但运算速度慢）

HTTPS 采用混合的加密机制，使用公开密钥加密用于传输对称密钥来保证安全性，之后使用对称密钥加密进行通信来保证效率。HTTPS是安全的HTTP通道，即在HTTP通信中加入了SSL层，通信的数据被加密了，防止被窃取。通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改），其具体的通信流程如下：

1.客户端发出https请求，请求服务端建立SSL连接

2.服务端收到https请求，申请或自制数字证书，得到公钥和服务端私钥，并将公钥发送给客户端

3.客户端验证公钥，不通过验证则发出警告，通过验证则产生一个随机的客户端私钥，使用公钥对客户端私钥进行非对称加密后传给服务端

4.服务端收到加密内容后，通过服务端私钥进行非对称解密，得到客户端私钥

5.在此之后，客户端与服务端都拿到了客户端的私钥，双方就可以基于客户端私钥进行对称加密的密文通信了

![https建立](..\image\https建立.png)

HTTP和HTTPS的区别如下：
（1）https协议需要到ca申请证书，一般免费证书很少，需要交费。
（2）http的信息是明文传输，https 则是具有安全性的ssl加密传输协议。
（3）http和https用的端口不一样，前者是80，后者是443。
（4）http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。