TCP是面向连接、可靠的、字节流传输。TCP协议通信双方必须先建立连接，通信双方必须为该连接分配必要的内核资源，以管理连接的状态和连接上数据的传输。TCP是全双工的，即双方的数据读写可通过一个连接进行。完成数据交换之后，通信双方都必须断开连接以释放系统资源。TCP协议的这种连接是一对一的，所以基于广播和多播（目标是多个主机地址）的应用程序不能使用TCP服务。而无连接的UDP则十分适合这种广播和多播。

 TCP协议使用字节流（UDP使用数据报），实际编程中字节流和数据报的主要区别体现在通信双方是否必须执行相同次数的读、写操作（只是表现形式），发送端应用程序连续执行多次写操作时，TCP模块先将这些数据放入TCP发送缓冲区中。当TCP模块真正开始发送数据时，发送缓冲区中这些等待发送的数据可能被封装成一个或多个TCP报文段发出。因此，TCP模块发送出的TCP模块发送出的TCP报文段的个数和应用程序执行的写操作次数之间没有固定的数量关系。

      当接收端收到一个或多个TCP报文段后，TCP模块将他们携带的应用程序数据按照TCP报文段的序号依次放入TCP接收缓冲区中，并通知应用程序读取数据。接收端应用程序可以一次性将TCP接收缓冲区中的数据全部都出，也可以分多次读取，这取决于用户制定的应用程序读缓冲区的大小。因此，应用程序执行的读操作次数和TCP模块接收到的TCP报文段个数之间也没有固定的数量关系。
    
    综上所述，发送端执行的写操作次数和接收端执行的读操作次数之间没有任何数量关系，这就是字节流的概念：应用程序对数据的发送和接收是没有边界限制的。UDP则然，发送端应用程序没执行一次写操作，UDP模块就将其封装成一个UDP数据包并发送之。接收端必须及时针对每一个UDP数据报执行读操作（通过recvfrom系统调用），否则就会丢包（这经常发生在较慢的服务器上）。并且，如果过用户没有指定足够的应用程序缓冲区来读取UDP数据，则UDP数据将被截断。
![TCP-UDP](..\image\TCP-UDP.png)



![TCP头部](..\image\TCP头部.png)

+ **16位端口号**：告知主机该报文段是来自哪里（源端口Source Port）以及传给哪个上层协议或应用程序（目的端口Destination Port）的。进行TCP通信时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号（比如DNS协议对应端口53，HTTP协议对应80，这些端口号可在/etc/services文件中找到）

+ **32位序号**：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。假设主机A和主机B进行TCP通信，A发送给B的第一个TCP报文段中，序号值被系统初始化为某个随机值ISN（Initial Sequence Number，初始序号值）。那么在该传输方向上（从A到B），后续的TCP报文段中序号值将被系统设置成ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个TCP报文段传送的数据是字节流中的第1025~2048字节，那么该报文段的序号值就是ISN+1025.另外一个传输方向（从B到A）的TCP报文段的序号值也具有相同的含义。

  > 在建⽴连接时由计算机⽣成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送⼀次数据，就「累加」⼀次该「数据字节数」的⼤⼩。⽤来解决⽹络包乱序问题。

+ **32位确认号（acknowledgement number）**：用作对另一方发送来的TCP报文段的响应。其值是收到的TCP报文段的序号值加1。假设主机A和主机B进行TCP通信，那么A发送出的TCP报文段不仅携带自己的序号，而且包含对B发送来的TCP报文段的确认号。反之，B发送出的TCP报文段也同时携带自己的序号和对A发送来的报文段的确认号。

  > 指下⼀次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序 号以前的数据都已经被正常接收。⽤来解决不丢包的问题。

+ **4位头部长度（header length）**：标识该TCP头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节

+ **6位标志位：**

  + URG标志，表示紧急指针（urgent pointer）是否有效。

  + ACK标志，表示确认号是否有效。我们称携带ACK标识的TCP报文段为确认报文段（**该位为1时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的SYN包之 外该位必须设置为1**）
  + PSH标志，提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在TCP接收缓冲区中）。
  +  RST标志，表示要求对方重新建立连接。我们称携带RST标志的TCP报文段为复位报文段(**该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接**)
  + SYN标志，表示请求建立一个连接。我们称携带SYN标志的TCP报文段为同步报文段(**该位为1时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定**)
  +  FIN标志，表示通知对方本端要关闭连接了。我们称携带FIN标志的TCP报文段为结束报文段(**该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的主机之间就可以相互交换 FIN 位为 1 的 TCP 段**)

+ **16位窗口大小（window size）**：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口（Receiver Window，RWND）。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度

+ **16位校验和（TCP check sum）：**由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。

+ **16位紧急指针（urgent pointer）**：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。

+ **TCP头部选项**：TCP头部的最后一个选项字段（options）是可变长的可选信息。这部分最多包含40字节，因为TCP头部最长是60字节（其中还包含前面讨论的20字节的固定部分）。

#### 为什么需要 TCP 协议？ TCP ⼯作在哪⼀层？

IP 层是「不可靠」的，它不保证⽹络包的交付、不保证⽹络包的按序交付、也不保证⽹络包中的数据的完整性。如果需要保障⽹络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责，TCP 是⼀个⼯作在传输层的可靠数据传输的服务，它能确保接收端接收的⽹络包是⽆损坏、⽆间隔、⾮冗余和按序的。

#### 什么是 TCP ？

TCP 是⾯向连接的、可靠的、基于字节流的传输层通信协议。

+ ⾯向连接：⼀定是「⼀对⼀」才能连接，不能像 UDP 协议可以⼀个主机同时向多个主机发送消 息，也就是⼀对多是⽆法做到的
+ 可靠的：⽆论的⽹络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报⽂⼀定能够到达接收端
+ 字节流：消息是「没有边界」的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是「有序 的」，当「前⼀个」消息没有收到的时候，即使它先收到了后⾯的字节，那么也不能扔给应⽤层去 处理，同时对「重复」的报⽂会⾃动丢弃。

#### 什么是 TCP 连接？

⽤于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗⼝⼤⼩称为连接。建⽴⼀个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识

+ Socket：由 IP 地址和端⼝号组成
+ 序列号：⽤来解决乱序问题等
+ 窗⼝⼤⼩：⽤来做流量控制

#### 如何唯⼀确定⼀个 TCP 连接呢？

TCP 四元组可以唯⼀的确定⼀个连接，四元组包括如下：源地址、源端口、目的地址、目的端口

> 源地址和⽬的地址的字段（32位）是在 IP 头部中，作⽤是通过 IP 协议发送报⽂给对⽅主机。
> 源端⼝和⽬的端⼝的字段（16位）是在 TCP 头部中，作⽤是告诉 TCP 协议应该把报⽂发给哪个进程。

#### 有⼀个 IP 的服务器监听了⼀个端⼝，它的 TCP 的最⼤连接数是多少？

服务器通常固定在某个本地端⼝上监听，等待客户端的连接请求。因此，客户端 IP 和 端⼝是可变的，其理论值计算公式如下:

> 最大TCP连接数 = 客户端的IP数 × 客户端的端口数量

对 IPv4，客户端的 IP 数最多为 2 的 32 次⽅，客户端的端⼝数最多为 2 的 16 次⽅，也就是服务 端单机最⼤ TCP 连接数，约为 2 的 48 次⽅。服务端最⼤并发 TCP 连接数远不能达到理论上限：⾸先主要是⽂件描述符限制，Socket 都是⽂件，所以⾸先要通过 ulimit 配置⽂件描述符的数⽬；另⼀个是内存限制，每个 TCP 连接都要占⽤⼀定内存，操作系统的内存是有限的

#### UDP 和 TCP 有什么区别呢？分别的应⽤场景是？

UDP 不提供复杂的控制机制，利⽤ IP 提供⾯向「⽆连接」的通信服务。UDP 协议真的⾮常简，头部只有 8 个字节（ 64 位），UDP 的头部格式如下：

![UDP头部](D:\WIN2020-10-30\wdya\image\UDP头部.png)

> ⽬标和源端⼝：主要是告诉 UDP 协议应该把报⽂发给哪个进程。
>
> 包⻓度：该字段保存了 UDP ⾸部的⻓度跟数据的⻓度之和。
>
> 校验和：校验和是为了提供可靠的 UDP ⾸部和数据⽽设计。

+ **连接:** TCP 是⾯向连接的传输层协议，传输数据前先要建⽴连接。 UDP 是不需要连接，即刻传输数据
+ **服务对象**：TCP 是⼀对⼀的两点服务，即⼀条连接只有两个端点。UDP ⽀持⼀对⼀、⼀对多、多对多的交互通信
+ **可靠性**：TCP 是可靠交付数据的，数据可以⽆差错、不丢失、不᯿复、按需到达。 UDP 是尽最⼤努⼒交付，不保证可靠交付数据
+ **拥塞控制、流量控制**：TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。 UDP 则没有，即使⽹络⾮常拥堵了，也不会影响 UDP 的发送速率。
+ **⾸部开销**：TCP ⾸部⻓度较⻓，会有⼀定的开销，⾸部在没有使⽤「选项」字段时是 20 个字节，如果使⽤ 了「选项」字段则会变⻓的。 UDP ⾸部只有 8 个字节，并且是固定不变的，开销较⼩
+ **传输方式**：TCP 是流式传输，没有边界，但保证顺序和可靠。 UDP 是⼀个包⼀个包的发送，是有边界的，但可能会丢包和乱序
+ **分⽚不同**：TCP 的数据⼤⼩如果⼤于 MSS（最大报文段长度） ⼤⼩，则会在传输层进⾏分⽚，⽬标主机收到后，也同样在传输层 组装 TCP 数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚。 UDP 的数据⼤⼩如果⼤于 MTU (最大传输单元)⼤⼩，则会在 IP 层进⾏分⽚，⽬标主机收到后，在 IP 层组装完数 据，接着再传给传输层，但是如果中途丢了⼀个分⽚，则就需要᯿传所有的数据包，这样传输效率 ⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU。

由于 TCP 是⾯向连接，能保证数据的可靠性交付，因此经常⽤于：FTP ⽂件传输、HTTP / HTTP；由于 UDP ⾯向⽆连接，它可以随时发送数据，再加上UDP本身的处理既简单⼜⾼效，因此经常⽤于：包总量较少的通信，如 DNS 、 SNMP 等；视频、⾳频等多媒体通信；⼴播通信

#### 为什么 UDP 头部没有「⾸部⻓度」字段，⽽ TCP 头部有「⾸部⻓度」字段呢？

TCP 有可变⻓的「选项」字段，⽽ UDP 头部⻓度则是不会变化的，⽆需多⼀个字段去记录 UDP 的⾸部⻓度。

#### 为什么 UDP 头部有「包⻓度」字段，⽽ TCP 头部则没有「包⻓度」字段呢？

TCP、UDP最大最小http://blog.sina.com.cn/s/blog_413d250e0102wmq0.html

UDP是无连接的, 你发包的时候必须要告诉对方你发了多长.要不对方不知道它应该接收多少,该处理多长？

TCP 是如何计算负载数据⻓度：

> TCP数据的长度 = IP总长度 - IP首部长度 - TCP首部长度

其中 IP 总⻓度 和 IP ⾸部⻓度，在 IP ⾸部格式是已知的。TCP ⾸部⻓度，则是在 TCP ⾸部格式已知
的，所以就可以求得 TCP 数据的⻓度。

虽然UDP 的数据⻓度也可以通过这个公式计算，但为了⽹络设备硬件设计和处理⽅便，⾸部⻓度需要是 44字节的整数倍。如果去掉 UDP 「包⻓度」字段，那 UDP ⾸部⻓度就不是 4 字节的整数倍了，

####  TCP 连接建立

TCP 是⾯向连接的协议，所以使⽤ TCP 前必须先建⽴连接，⽽建⽴连接是通过三次握⼿来进⾏的。

![TCP连接](..\image\TCP连接.png)

+ ⼀开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端⼝，处于 LISTEN 状 态。客户端会随机初始化序号（ client_isn ），将此序号置于 TCP ⾸部的「序号」字段中，同时把 SYN 标志位置为 1 ，表示 SYN 报⽂。接着把第⼀个 SYN 报⽂发送给服务端，表示向服务端发 起连接，该报⽂不包含应⽤层数据，之后客户端处于 SYN-SENT 状态。
+ 服务端收到客户端的 SYN 报⽂后，⾸先服务端也随机初始化⾃⼰的序号（ server_isn ），将此 序号填⼊ TCP ⾸部的「序号」字段中，其次把 TCP ⾸部的「确认应答号」字段填⼊ client_isn + 1 , 接着把 SYN 和 ACK 标志位置为 1 。最后把该报⽂发给客户端，该报⽂也不包含应⽤层数 据，之后服务端处于 SYN-RCVD 状态。
+ 客户端收到服务端报⽂后，还要向服务端回应最后⼀个应答报⽂，⾸先该应答报⽂ TCP ⾸部 ACK 标志位置为 1 ，其次「确认应答号」字段填⼊ server_isn + 1 ，最后把报⽂发送给服务端，这 次报⽂可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 状态。服务器收到客户端的应答报⽂后，也进⼊ ESTABLISHED 状态。

发送第一个S Y N的一端将执行主动打开（ active open）。接收这个S Y N并发回下一个S Y N 的另一端执行被动打开（passive open）。第三次握⼿是可以携带数据的，前两次握⼿是不可以携带数据的，⼀旦完成三次握⼿，双⽅都处于 ESTABLISHED 状态，此时连接就已建⽴完成，客户端和服务端就可以 相互发送数据了。

#### 为什么是三次握⼿？不是两次、四次？

TCP 连接是⽤于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗⼝⼤ ⼩称为连接，三次握⼿才可以初始化Socket、序列号和窗⼝⼤⼩并建⽴ TCP 连接。

+ 三次握手才可以阻⽌重复历史连接的初始化：为了防⽌旧的重复连接初始化造成混乱，网络环境是错综复杂的，往往并不是如我们期望的⼀样，可能会由于⽹络拥堵等乱七⼋糟的原因，会使得旧的数据包，先到达目标主机，即客户端连续发送多次 SYN 建⽴连接的报⽂，在⽹络拥堵情况下，⼀个「旧 SYN 报⽂」⽐「最新的 SYN 」 报⽂早到达了服务端，那么此时服务端就会回⼀个 SYN + ACK 报⽂给客户端，客户端收到后可以根据⾃身的上下⽂，判断这是⼀个历史连接（序列号过期，Ack不是自己期望的或超时），那么客户端 就会发送 RST 报⽂给服务端，表示中⽌这⼀次连接

  > 如果是两次握⼿连接，就不能判断当前连接是否是历史连接，三次握⼿则可以在客户端（发送⽅）准备发送第三次报⽂时，客户端因有⾜够的上下⽂来判断当前连接是否是历史连接：如果是历史连接（序列号过期或超时），则第三次握⼿发送的报⽂是 RST 报⽂，以此中⽌历史连 接； 如果不是历史连接，则第三次发送的报⽂是 ACK 报⽂，通信双⽅就会成功建⽴连接

+ 三次握手才可以同步双方的初始序列号：TCP 协议的通信双⽅， 都必须维护⼀个「序列号」， 序列号是可靠传输的⼀个关键因素，它的作⽤有

  + 接收⽅可以去除重复的数据
  + 接收⽅可以根据数据包的序列号按序接收
  + 可以标识发送出去的数据包中， 哪些是已经被对⽅收到的

  序列号在 TCP 连接中占据着⾮常重要的作⽤，所以当客户端发送携带「初始序列号」的 SYN 报 ⽂的时候，需要服务端回⼀个 ACK 应答报⽂，表示客户端的 SYN 报⽂已被服务端成功接收，那当服 务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样⼀来⼀回，才能确保 双⽅的初始序列号能被可靠的同步。

  > 四次握⼿(一来一会、一来一会)其实也能够可靠的同步双⽅的初始化序号，但由于第⼆步和第三步可以优化成⼀步，所以就成 了「三次握⼿」。 
  >
  > 两次握⼿只保证了⼀⽅的初始序列号能被对⽅成功接收，没办法保证双⽅的初始序列号都能被确认接 收。

+ 三次握⼿才可以避免资源浪费：如果只有「两次握手」，当客户端的 SYN 请求连接在⽹络中阻塞，客户端没有接收到 ACK 报文，就 会重新发送 SYN ，由于没有第三次握⼿，服务器不清楚客户端是否收到了自己发送的建⽴连接的 ACK 确认信号，所以每收到⼀个 SYN 就只能先主动建立⼀个连接，这会造成服务器在收到请求后就会建⽴多个冗余的无效链接，造成不必要的资源浪费。即两次握⼿会造成消息滞留情况下，服务器重复接受无用的连接请求 SYN 报⽂，而造成重复分配资源。

TCP 建立连接时，通过三次握⼿能防⽌历史连接的建⽴，能减少双⽅不必要的资源开销，能帮助双方同 步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。

> 「两次握⼿」：⽆法防⽌历史连接的建⽴，会造成双⽅资源的浪费，也⽆法可靠的同步双⽅序列号；
>
> 「四次握⼿」：三次握⼿就已经理论上最少可靠连接建⽴，所以不需要使⽤更多的通信次数。

#### 为什么客户端和服务端的初始序列号 ISN 是不相同的？

如果⼀个已经失效的连接被重⽤了，但是该旧连接的历史报⽂还残留在⽹络中，如果序列号相同，那么 就⽆法分辨出该报⽂是不是历史报⽂，如果历史报⽂被新的连接接收了，则会产⽣数据错乱。 所以，每次建⽴连接前重新初始化⼀个序列号主要是为了通信双⽅能够根据序号将不属于本连接的报⽂ 段丢弃。 另⼀⽅⾯是为了安全性，防⽌⿊客伪造的相同序列号的 TCP 报⽂被对⽅接收

#### 初始序列号 ISN 是如何随机产⽣的？

起始 ISN 是基于时钟的，每 4 毫秒 + 1，转⼀圈要 4.55 个⼩时。 RFC1948 中提出了⼀个较好的初始化序列号 ISN 随机⽣成算法：ISN = M + F (localhost, localport, remotehost, remoteport）

> M 是⼀个计时器，这个计时器每隔 4 毫秒加 1。
>
> F 是⼀个 Hash 算法，根据源 IP、⽬的 IP、源端⼝、⽬的端⼝⽣成⼀个随机数值。要保证 Hash 算法不能被外部轻易推算得出，⽤ MD5 算法是⼀个⽐较好的选择。

#### 既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？

MTU ：⼀个网络包的最大长度，以太网中⼀般为 1500 字节； MSS ：除去 IP 和 TCP 头部之后，⼀个网络包所能容纳的 TCP 数据的最大长度；

![MTU](..\image\MTU.png)

+ MTU ：⼀个网络包的最大长度，以太网中⼀般为 1500 字节
+ MSS ：除去 IP 和 TCP 头部之后，⼀个网络包所能容纳的 TCP 数据的最大长度；

为了达到最佳的传输效能 TCP 协议在建⽴连接的时候通常要协商双方的 MSS 值，当 TCP 层发 现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，⾃然也就 不用 IP 分片了。经过 TCP 层分片后，如果⼀个 TCP 分片丢失后，进行重发时也是以 MSS 为单位，而不用重传所有的 分片，大大增加了重传的效率

#### 什么是 SYN 攻击？如何避免 SYN 攻击？

我们都知道 TCP 连接建⽴是需要三次握⼿，假设攻击者短时间伪造不同 IP 地址的 SYN 报⽂，服务端 每接收到⼀个 SYN 报⽂，就进⼊ SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报⽂，⽆法得到 未知 IP 主机的 ACK 应答，久⽽久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不 能为正常⽤户服务。避免 SYN 攻击有

+ 通过修改 Linux 内核参数，控制队列⼤⼩和当队列满时应做什么处理

  + 当⽹卡接收数据包的速度⼤于内核处理的速度时，会有⼀个队列保存这些数据包。控制该队列的最 ⼤值如下参数

    > net.core.netdev_max_backlog

  + SYN_RCVD 状态连接的最⼤个数

    > net.ipv4.tcp_max_syn_backlog

  + 超出处理能时，对新的 SYN 直接回报 RST，丢弃连接

    > net.ipv4.tcp_abort_on_overflow

+ Linux 内核的 SYN (未完成连接建立)队列与 Accpet （已完成连接建⽴）队列

  ![SYN攻击](..\image\SYN攻击.png)

  + 当服务端接收到客户端的 SYN 报⽂时，会将其加⼊到内核的「 SYN 队列」
  +  接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报⽂
  +  服务端接收到 ACK 报⽂后，从「 SYN 队列」移除放⼊到「 Accept 队列」
  +  应⽤通过调⽤ accpet() socket 接⼝，从「 Accept 队列」取出连接。

#### TCP 第⼀次握⼿的 SYN 丢包了，会发⽣了什么？

​		当客户端发起的 TCP 第⼀次握⼿ SYN 包，在超时时间内没收 到服务端的 ACK，就会在超时重传 SYN 数据包，每次超时重传的 RTO 是翻倍上涨的，直到 SYN 包的重传次数到达 tcp_syn_retries 值后，客户端不再发送 SYN 包。

客户端发起了 SYN 包后，⼀直没有收到服务端的 ACK ，所以⼀直超时重传了5次，并且每次 RTO 超时时间是不同的，每次超时时间 RTO 是指数(翻倍)上涨的，当超过最⼤重传次数后，客户端不再发送 SYN 包。

```
第一次访问  11:00:35
重试第⼀次间隔1秒超时重传	11:00:36
重试第⼆次间隔2秒超时重传	11:00:38
重试第三次间隔4秒超时重传	11:00:42
重试第四次间隔8秒超时重传	11:00:50
重试第五次间隔16秒超时重传	11:01:06
```

```shell
# uname -srm
Linux 3.10.0-1160.6.1.el7.x86_64 x86_64

3 - 内核版本.
10 - 主修订版本.
0-1160 - 次要修订版本.
6 - 补丁版本.


修改tcp_syn_retries为2
# echo 2 > /proc/sys/net/ipv4/tcp_syn_retries
```

/proc/sys/net/ipv4/tcp_syn_retries 的值表示socket客户端进行s.connect()连接时，在服务端未返回SYN + ACK标识的情况下，也就是连接超时后，离第一次SYN包发送之后的重试次数，包括重试时间的计算。**tcp_syn_retries**默认是5,本机主动发起SYN连接，如果一直收不到服务端返回的SYN + ACK,那么应用程序最大的超时时间就是127秒，也就是2^6次幂-1

理想情况下，第 1 次重试发生在 1 秒钟后，接着会以翻倍的方式在第 2、4、8、16秒共做 5次重试，最后一次重试后会等待32秒，如果仍然没有返回 ACK，才会终止三次握手。所以，总耗时是 1+2+4+8+16+32=63秒，超过1分钟。实际中并不会让客户端重试这么多次，比如在socket连接中会定义超时时间。超过时间，则不再发送syn，例如在建立socket连接时设置超时3秒后，重试第一次和第二次加起来用了3秒，客户端超时后结束就结束

#### TCP 第⼆次握⼿的 SYN、ACK 丢包了，会发⽣什么？

当第⼆次握⼿的 SYN、ACK 丢包时，客户端会超时重发 SYN 包，服务端也会超时重传 SYN、ACK 包。

+ 客户端发起 SYN 后，由于防⽕墙屏蔽了服务端的所有数据包，所以 curl 是⽆法收到服务端的 SYN、ACK 包，当发⽣超时后，就会重传 SYN 包
+ 服务端收到客户的 SYN 包后，就会回 SYN、ACK 包，但是客户端⼀直没有回 ACK，服务端在超时后，重传了 SYN、ACK 包，接着⼀会，客户端超时重传的 SYN 包⼜抵达了服务端，服务端收到后，超时定时器就重新计时，然后回了 SYN、ACK 包，所以相当于服务端的超时定时器只触发了 ⼀次，⼜被重置了。
+ 最后，客户端 SYN 超时重传次数达到了5次（tcp_syn_retries 默认值5次），就不再继续发送 SYN 包了。

TCP 第⼆次握⼿ SYN、ACK 包的最⼤重传次数是通过 **tcp_synack_retries**内核参数限制的，其默认值如下：

```shell
# cat /proc/sys/net/ipv4/tcp_synack_retries
5
```

#### TCP 第三次握⼿的 ACK 包丢了，会发⽣什么？

在建⽴ TCP 连接时，如果第三次握⼿的 ACK，服务端⽆法收到，则服务端就会短暂处于 SYN_RECV 状 态，⽽客户端会处于 ESTABLISHED 状态。 

由于服务端⼀直收不到 TCP 第三次握⼿的 ACK，则会⼀直重传 SYN、ACK 包，直到重传次数超过 tcp_synack_retries 值（默认值 5 次）后，服务端就会断开 TCP 连接。 

⽽客户端则会有两种情况： 

1. 如果客户端没发送数据包，⼀直处于 ESTABLISHED 状态，然后经过 2 ⼩时 11 分 15 秒才可以发现 ⼀个「死亡」连接，于是客户端连接就会断开连接
2. 如果客户端发送了数据包，⼀直没有收到服务端对该数据包的确认报⽂，则会⼀直重传该数据包， 直到重传次数超过 tcp_retries2 值（默认值 15 次）后，客户端就会断开 TCP 连接。

服务端收不到第三次握⼿的 ACK 包超时重传SYN、ACK报后还是收不到ACK，然后就断开了，在重传SYN/ACK期间⼀直处于 SYN_RECV 状态；而客户端是已完成 TCP 连接建⽴，处于 ESTABLISHED 状态

+ 若在服务端断开的情况下客户端发送数据，会⼀直在超时重传，每⼀次重传，RTO 的值 是指数增⻓的，直到tcp_retries2次数时客户端才会断开连接。TCP 建⽴连接后的数据包传输，最⼤超时重传次数是由 tcp_retries2 指定，默认值是 15 次

  ```shell
  # cat /proc/sys/net/ipv4/tcp_retries2
  15
  ```

+ 若在服务端断开的情况下客户端不发送数据：TCP有个保活机制。这个机制的原理是这样的： 定义⼀个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作⽤，每隔⼀ 个时间间隔，发送⼀个「探测报⽂」，该探测报⽂包含的数据⾮常少，如果连续⼏个探测报⽂都没有得 到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应⽤程序。

  ```
  # cat /etc/sysctl.conf
  ```

  ```
  net.ipv4.tcp_keepalive_time=7200//保活时间
  net.ipv4.tcp_keepalive_intvl=75//保活探测的次数
  net.ipv4.tcp_keepalive_probes=9//保活探测的时间间隔
  ```

  + tcp_keepalive_time=7200：表示保活时间是 7200 秒（2⼩时），也就 2 ⼩时内如果没有任何连接 相关的活动，则会启动保活机制
  + tcp_keepalive_intvl=75：表示每次检测间隔 75 秒； 
  + tcp_keepalive_probes=9：表示检测 9 次⽆响应，认为对⽅是不可达的，从⽽中断本次的连接。

  > 7200+(75*9)=7875

  也就是说在 Linux 系统中，最少需要经过 2 ⼩时 11 分 15 秒才可以发现⼀个「死亡」连接。

#### TCP断开

双⽅都可以主动断开连接，断开连接后主机中的「资源」将被释放

![TCP断开](..\image\TCP断开.png)

+ 客户端打算关闭连接，此时会发送⼀个 TCP ⾸部 FIN 标志位被置为 1 的报⽂，也即 FIN 报 ⽂，之后客户端进⼊ FIN_WAIT_1 状态
+  服务端收到该报⽂后，就向客户端发送 ACK 应答报⽂，接着服务端进⼊ CLOSED_WAIT 状态
+ 客户端收到服务端的 ACK 应答报⽂后，之后进⼊ FIN_WAIT_2 状态
+ 等待服务端处理完数据后，也向客户端发送 FIN 报⽂，之后服务端进⼊ LAST_ACK 状态
+ 客户端收到服务端的 FIN 报⽂后，回⼀个 ACK 应答报⽂，之后进⼊ TIME_WAIT 状态
+ 服务器收到了 ACK 应答报⽂后，就进⼊了 CLOSED 状态，⾄此服务端已经完成连接的关闭
+ 客户端在经过 2MSL ⼀段时间后，⾃动进⼊ CLOSED 状态，⾄此客户端也完成连接的关闭

每个⽅向都需要⼀个 FIN 和⼀个 ACK，因此通常被称为四次挥⼿，主动关闭连接的，才有 TIME_WAIT 状态

#### 为什么挥手需要四次？

+ 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。
+ 服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂，⽽服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接

服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN ⼀般都会 分开发送，从⽽⽐三次握⼿导致多了⼀次

```
如果服务器端收到客户端的 FIN 后，服务器端同时也要关闭连接，这样就可以把 ACK 和 FIN 合并到⼀起发送，节省了⼀个包，变成了“三次挥⼿”。
⽽通常情况下，服务器端收到客户端的 FIN 后，很可能还没发送完数据，所以就会先回复客户端⼀个ACK 包，稍等⼀会⼉，完成所有数据包的发送后，才会发送 FIN 包，这也就是四次挥⼿了。
```

#### 为什么 TIME_WAIT 等待的时间是 2MSL？

​		MSL 是 Maximum Segment Lifetime，报⽂最⼤⽣存时间，它是任何报⽂在⽹络上存在的最⻓时间，超过这个时间报⽂将被丢弃。因为 TCP 报⽂基于是 IP 协议的，⽽ IP 头中有⼀个 TTL 字段，是 IP 数据报可以经过的最⼤路由数，每经过⼀个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报⽂通知源主机。

​		MSL 与 TTL 的区别： MSL 的单位是时间，⽽ TTL 是经过路由跳数。所以 MSL 应该要⼤于等于 TTL消耗为 0 的时间，以确保报⽂已被⾃然消亡。

TIME_WAIT 等待 2 倍的 MSL，⽐较合理的解释是： ⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 2 倍的时间。⽐如如果被动关闭⽅没有收到断开连接的最后的 ACK 报⽂，就会触发超时᯿发 Fin 报⽂，另⼀⽅接收到 FIN 后，会重发 ACK 给被动关闭⽅， ⼀来⼀去正好 2 个 MSL。2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端⼜接收到了服务端᯿发的 FIN 报⽂，那么 2MSL 时间将重新计
时。在 Linux 系统⾥ 2MSL 默认是 60 秒，那么⼀个 MSL 也就是 30 秒。Linux 系统停留在TIME_WAIT 的时间为固定的 60 秒

> \#define TCP_TIMEWAIT_LEN (60*HZ)

#### 为什么需要 TIME_WAIT 状态？

主动发起关闭连接的⼀⽅，才会有 TIME-WAIT 状态。需要 TIME-WAIT 状态，主要是两个原因：

+ 防⽌具有相同「四元组」的「旧」数据包被收到：经过 2MSL 这个时间，⾜以让两个⽅向上的数据包都被丢弃， 使得原来连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣的。

  ```
  假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后，那么客户端是有可能正常接收这个过期的报⽂，这就会产⽣数据错乱等严重的问题。
  ```

+ 保证「被动关闭连接」的⼀⽅能被正确的关闭，即保证最后的 ACK 能让被动关闭⽅接收，从⽽帮 助其正常关闭

  假设 TIME-WAIT 没有等待时间或时间过短

  + 如何客户端四次挥⼿的最后⼀个 ACK 报⽂如果在⽹络中被丢失了，而客户端已经进⼊了 CLOSED 状态了，那么服务端则会⼀直处在 LASE_ACK状态。当客户端发起建⽴连接的 SYN 请求报⽂后，服务端会发送 RST 报⽂给客户端，连接建⽴的过程就会被终⽌。

  如果 TIME-WAIT 等待⾜够⻓

  + 服务端正常收到四次挥⼿的最后⼀个 ACK 报⽂，则服务端正常关闭连接。
  + 服务端没有收到四次挥⼿的最后⼀个 ACK 报⽂时，则会᯿发 FIN 关闭连接报⽂并等待新的 ACK 报⽂

所以客户端在 TIME-WAIT 状态等待 2MSL 时间后，就可以保证双⽅的连接都可以正常的关闭。

#### TIME_WAIT 过多有什么危害？

如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器⽅主动发起的断开请求，过多的 TIME-WAIT 状态主要的危害有两种：

+ 内存资源占⽤
+ 对端⼝资源的占⽤，⼀个 TCP 连接⾄少消耗⼀个本地端⼝

如果发起连接⼀⽅的 TIME_WAIT 状态过多，占满了所有端⼝资源，则会导致⽆法创建新连接。

客户端受端⼝资源限制：客户端TIME_WAIT过多，就会导致端⼝资源被占⽤，因为端⼝就65536个，被占满就会导致⽆法创 建新的连接。

服务端受系统资源限制：由于⼀个四元组表示 TCP 连接，理论上服务端可以建⽴很多连接，服务端确实只监听⼀个端⼝ 但 是会把连接扔给处理线程，所以理论上监听的端⼝可以继续监听。但是线程池处理不了那么多⼀直 不断的连接了。所以当服务端出现⼤量 TIME_WAIT 时，系统资源被占满时，会导致处理不过来新 的连接。

#### 如何优化 TIME_WAIT？

#### 如果已经建⽴了连接，但是客户端突然出现故障了怎么办？

TCP 有⼀个机制是保活机制。这个机制的原理是这样的：定义⼀个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作⽤，每隔⼀ 个时间间隔，发送⼀个探测报⽂，该探测报⽂包含的数据⾮常少，如果连续⼏个探测报⽂都没有得到响 应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应⽤程序。在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为 默认值：

> net.ipv4.tcp_keepalive_time=7200
>
> net.ipv4.tcp_keepalive_intvl=75
>
> net.ipv4.tcp_keepalive_probes=9

+ tcp_keepalive_time=7200：表示保活时间是 7200 秒（2⼩时），也就 2 ⼩时内如果没有任何连接 相关的活动，则会启动保活机制 
+ tcp_keepalive_intvl=75：表示每次检测间隔 75 秒； 
+ tcp_keepalive_probes=9：表示检测 9 次⽆响应，认为对⽅是不可达的，从⽽中断本次的连接。

也就是说在 Linux 系统中，最少需要经过 2 ⼩时 11 分 15 秒才可以发现⼀个「死亡」连接。

![TCP保活机制](..\image\TCP保活机制.png)

这个时间是有点⻓的，我们也可以根据实际的需求，对以上的保活相关的参数进⾏设置。如果开启了 TCP 保活，需要考虑以下⼏种情况：

+ 第⼀种，对端程序是正常⼯作的。当 TCP 保活的探测报⽂发送给对端, 对端会正常响应，这样 TCP 保 活时间会被重置，等待下⼀个 TCP 保活时间的到来。 
+ 第⼆种，对端程序崩溃并重启。当 TCP 保活的探测报⽂发送给对端后，对端是可以响应的，但由于没 有该连接的有效信息，会产⽣⼀个 RST 报⽂，这样很快就会发现 TCP 连接已经被重置
+ 第三种，是对端程序崩溃，或对端由于其他原因导致报⽂不可达。当 TCP 保活的探测报⽂发送给对端 后，⽯沉⼤海，没有响应，连续⼏次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。