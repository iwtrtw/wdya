https://www.cnblogs.com/paddix/p/5405678.html

​       造成线程安全问题的主要原因有两个，一是存在共享数据(也称临界资源)，二是存在多条线程共同操作共享数据。为了解决这个问题，可以使用互斥锁，保证当存在多个线程操作共享数据时，每次只能有一个线程可以操作共享数据，而其他线程只能等待。而sychronized可以其到这样的作用，synchronize可以保证在同一时刻，只有一个线程可以执行sychronized修饰某个方法或代码块（同时，synchronized也可以保证共享数据的变化别其他线程可以看到）

​      synchronized的用法有三种方式

+ 修饰静态方法，加锁的对象是当前类对象，想要进入同步代码必须先获取当前类的锁
+ 修饰实例方法，加锁的对象是当前实例，想要进入同步代码块之前必须先获取当前对象的锁
+ 修饰代码块，指定加锁对象，对给定的对象加锁，进入同步代码块之前必须先获得当前对象的锁

​      synchronized是基于进入和退出montior对象来实现，包括显示同步(synchronized修饰同步代码块时，同步代码块的字节码反编译之后会有明确的monitorenter和monitoexit指令)，还有隐式同步(synchronized修饰方法，同步方法的字节码反编译之后会有个标志位ACC_SYNCHRONIZED)

​      在Java中关于synchronized的锁信息存放于Java对象头中，在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据、填充数据

+ 对象头：Mark Word（默认情况下存储着对象的HashCode、分代年龄、锁标记位等）+ Class Metadata Address

| 锁状态   | 25bit                | 4bit         | 1bit | 2bit |
| -------- | -------------------- | ------------ | ---- | ---- |
| 无锁     | 对象HashCode         | 对象分代年龄 | 0    | 01   |
| 偏向锁   | 线程id+Epoch         | 对象分代年龄 | 1    | 01   |
| 轻量级锁 | 指向栈中锁记录的指针 |              |      | 00   |
| 重量级锁 | 指向monitor的指针    |              |      | 10   |
| GC标志   | 空                   |              |      | 11   |

+ 实例数据：
+ 填充数据：



每个对象都存在着一个 monitor 与之关联，monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下

```

```

