https://tech.meituan.com/2018/11/15/java-lock.html

​       造成线程安全问题的主要原因有两个，一是存在共享数据(也称临界资源)，二是存在多条线程共同操作共享数据。为了解决这个问题，可以使用互斥锁，保证当存在多个线程操作共享数据时，每次只能有一个线程可以操作共享数据，而其他线程只能等待。而sychronized可以其到这样的作用，synchronize可以保证在同一时刻，只有一个线程可以执行sychronized修饰某个方法或代码块（同时，synchronized也可以保证共享数据的变化别其他线程可以看到）

​      synchronized的用法有三种方式

+ 修饰静态方法，加锁的对象是当前类对象，想要进入同步代码必须先获取当前类的锁
+ 修饰实例方法，加锁的对象是当前实例，想要进入同步代码块之前必须先获取当前对象的锁
+ 修饰代码块，指定加锁对象，对给定的对象加锁，进入同步代码块之前必须先获得给定对象的锁

​      synchronized是基于进入和退出montior对象来实现，包括显示同步(synchronized修饰同步代码块时，同步代码块的字节码反编译之后会有明确的monitorenter和monitoexit指令)，还有隐式同步(synchronized修饰方法，同步方法的字节码反编译之后会有个标志位ACC_SYNCHRONIZED,线程在执行方法前会先去获取对象的monitor对象，如果获取成功则执行方法代码，执行完毕后释放monitor对象，如果monitor对象已经被其它线程获取，那么当前线程被阻塞)

#### 对象内存

​      在Java中关于synchronized的锁信息存放于Java对象头中，在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据、填充数据

+ 对象头：Mark Word+ Klass Word(32bits/64bit)+array length(32bits)

**MarkWord**：存储对象自身的运行时数据，如HashCode、分代年龄、锁标记位等,32位JVM的Mark word占32位，64位的JVM为64位

| 锁状态   | 25bit                                 | 4bit         | 1bit                 | 2bit |
| -------- | ------------------------------------- | ------------ | -------------------- | ---- |
| 无锁     | 对象HashCode                          | 对象分代年龄 | 0                    | 01   |
| 偏向锁   | 线程id(23bit)+epoch(2bit、偏向时间戳) | 对象分代年龄 | 1                    | 01   |
| 轻量级锁 | 指向栈中锁记录的指针                  | ...30bit...  | 指向栈中锁记录的指针 | 00   |
| 重量级锁 | 指向monitor的指针                     | ...30bit...  | 指向monitor的指针    | 10   |
| GC标志   | 空                                    | .......      | 空                   | 11   |

| 锁状态   | 25bit                | 31bit                 | 1bit   | 4bit         | 1bit                 | 2bit |
| -------- | -------------------- | --------------------- | ------ | ------------ | -------------------- | ---- |
| 无锁     | unused               | 对象HashCode          | unused | 对象分代年龄 | 0                    | 01   |
| 偏向锁   | 线程id(55bit)        | poch(偏向时间戳,2bit) | unused | 对象分代年龄 | 1                    | 01   |
| 轻量级锁 | 指向栈中锁记录的指针 | ...                   | 62bit  | ...          | 指向栈中锁记录的指针 | 00   |
| 重量级锁 | 指向monitor的指针    | ...                   | 62bit  | ...          | 指向monitor的指针    | 10   |
| GC标志   | 空                   |                       |        |              | 空                   | 11   |

**class pointer**：指向类的指针,指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例，32位的JVM为32位，64位的JVM为64位。为了节约内存可以使用选项`+UseCompressedOops`开启指针压缩，开启该选项后，指针将压缩至32位

**array length**：如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度

+ 实例数据：对象属性及其值
+ 填充数据：JVM要求java的对象占的内存大小应该是8bit的倍数，所以后面有几个字节用于把对象的大小补齐至8bit的倍数

#### CAS

​		CAS是一种乐观锁策略，它假设所有线程访问共享资源的时候不会出现冲突，在操作时，不会将其他线程阻塞，是一种无锁操作，通过比较交换不断重试当前操作直到没有冲突，操作成功。在CAS中会涉及三个重要的值，目标对象V，旧值O，N更新值，只要当目标对象的实际值与旧值相同，新值才会更新成功。当V==O相同时，也就是说预期值和内存中实际的值相同，表明该值没有被其他线程更改过，即预期值O就是目前来说最新的值了，可以将N赋给V。当V!=O不相同，表明V值已经被其他线程改过了，即预期值0不是最新值了，所以不能将新值N赋给V，返回V值，将O值改为V。

#### synchronized锁升级

​		偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。

> 1. 当没有被当成锁时，就是一个普通的对象，Mark Word记录对象的HashCode，锁标志位是01，是否偏向锁标志为0。
>
> 2. 当对象被当做同步锁时，通常是从偏向锁开始（大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁）此时锁标志位还是01，但是否偏向锁标志位会变为1，原本记录对象hashcode的位置会改为记录抢到锁的线程id、以及加锁时间戳epoch(在32为JVM中，23bit记录抢到锁的线程id,2bit记录时间戳)；偏向锁加锁的过程如下：
>
>    + 首先判断一下当前线程id是否与Markword当中的线程id是否一致
>    + 如果一致，则说明此线程之前已经成功获得了锁，而且现在没有竞争，则继续执行同步代码块，不需要再使用CAS操作加锁、解锁
>    + 如果不一致，则要检查一下对象是否还是可偏向，即“是否偏向锁”标志位的值，如果还未偏向，则利用CAS操作来竞争锁，通过CAS尝试将线程ID设置到对象的Mark Word头，即第一次获取锁时的操作
>
> 3. 在偏向锁状态下时，一开始有一个线程A已经获得了偏向锁，此时有其他线程B也尝试用CAS操作试图获取锁时，如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则代表存在竞争，那么会先撤销已获得偏向 锁的线程(撤销偏向锁的过程非常消耗性能,如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么频繁偏向锁撤销会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭)，并且把它持有的锁升级为轻量级锁。偏向锁的撤销需要等到全局安全点才可以执行（即没有线程在执行字节码），偏向锁的撤销分两种情况（无锁状态或轻量级锁）：
>
>    + 原获得偏向锁的线程如果已经退出了临界区，也就是同步代码块执行完了，那么这个时候会把对象头设置成无锁状态并且争抢锁的线程可以基于CAS 重新偏向但前线程
>    + 如果原获得偏向锁的线程的同步代码块还没执行完，处 于临界区之内，这个时候会把原获得偏向锁的线程升级为轻量级锁后继续执行同步代码块
>
>    ![偏向锁撤销](/image/偏向锁撤销.png)
>
> 4. 锁升级为轻量级锁后，线程会在自己的栈帧中创建锁记录LockRecord，将对象头中的 Mark Word 复制到 LockRecord 中，使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。如果CAS操作成功，代表线程抢锁成功，将Mark Word锁标志设为00，表示对象处于轻量级锁定状态。如果CAS操作失败，首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁，若当前只有一个等待线程，不会直接升级为重量级锁，会先自旋等待，不断重试，尝试去抢锁（从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定）当自旋次数到一定时，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。
>
>    + 自旋，就是指当有另外一个线程来竞争锁时，这个线 程会在原地循环等待，而不是把该线程给阻塞，直到那个 获得锁的线程释放锁之后，这个线程就可以马上获得锁的。锁在原地循环的时候，是会消耗 cpu 的，就相当于 在执行一个啥也没有的 for 循环。轻量级锁适用于那些同步代码块执行的很快的场景，这样，线程原地等待很短的时间就能够获得锁了
>    + 轻量级锁解锁时，会使用CAS操作将Displaced Mark Word替换回到对象头，如果成功，表示没有竞争发生。如果失败，表示当前锁存在竞争，锁已经被升级为重量级锁，则会释放锁并唤醒等待的线程。
>
> 5. 锁会升级为重量级锁后，Mark Word中存储了指向重量级监视器锁的指针，锁标志位会变为10。锁对象会与一个监视器 monitor 关联，当一个线程想要执行一段被 synchronized 修饰的同步方法或者代码块时，该线程得先尝试获取到 synchronized 修饰的对象对应的 monitor。重量级锁状态下把除了拥有锁的线程，其他尝试获取锁的线程都会进入阻塞状态，不会通过自旋方式获取锁，防止CPU空转。

每个对象都存在着一个 monitor 与之关联，monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下:

```cpp
ObjectMonitor() {
    _header       = NULL;
    _count        = 0; //记录个数
    _waiters      = 0,
    _recursions   = 0;//锁的重入次数
    _object       = NULL;
    _owner        = NULL; //指向持有ObjectMonitor对象的线程
    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
  }
```

ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程

1. 当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，此时线程处于blocking状态
2. 当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量指向当前线程，计数器count加1
3. 当同步代码块中正运行running的线程调用 wait() 方法时，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒。
4. 若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)

monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。