## Mysql事务

### 事务四个特性(ACID)

事务是数据库管理系统（DBMS）执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成；

+ 原子性：**对数据库的一系列的操作，要么都是成功，要么都是失败**，不可能出现部分成功或者部分失败的情况；在 InnoDB 里面是通过 undo log 来实现的，它记录了数据修改之前的值（逻辑日志），一旦发生异常，就可以用 undo log 来实现回滚操作。
+ 一致性：是数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。
+ 隔离性：在数据库里面会有很多的 事务同时去操作我们的同一张表或者同一行数据，必然会产生一些并发或者干扰的操作， 那么我们对隔离性的定义，就是这些很多个的事务，对表或者行的并发操作，应该是透明的，互相不干扰的。通过这种方式，我们最终也是保证业务数据的一致性。
+ 持久性：我们对数据库的任意的操作，增删改，只要事务提交成功，那么结果就是永久性的，不可能因为我们系统宕机或者重启了数据库的服务器，它又恢复到原来的状态了；在Innodb中，持久性是通过 redo log 和 double write 双写缓冲来实现的。

### 数据一致性问题

+ **脏读**：A事务读取B事务尚未提交的数据并在此基础上操作，而B事务执行回滚，那么A读取到的数据就是脏数据
+ **不可重复读：**事务A重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务B修改过了，或者被删除了
+ **幻读：**事务A重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务B提交的行。
+ **回滚丢失**：A和B一起执行了一个数据，然后B事务先提交，后来A事务回滚，那么B事务的操作会因为A事务回滚而丢失
+ **提交覆盖丢失**：A和B同时操作同一数据，B事务先提交，后来A事务也提交了，那么可能会造成B事务丢失

**不可重复读是修改或者删除，幻读是插入**

### 事务隔离级别

+ **读未提交(RU)**：一个事务还没提交时，它做的变更就能被别的事务看到。

  > 不加锁

+ **读提交(RC)**：一个事务提交之后，它做的变更才会被其他事务看到。

  > RC 隔离级别下，普通的 select 都是快照读，使用 MVCC 实现。
  >
  > 加锁的 select 都使用记录锁，因为没有 Gap Lock
  >
  > **外键约束检查**(foreign-key constraint checking)以及**重复键检查**(duplicate-key checking)时会使用间隙锁封锁区间；**所以 RC 会出现幻读的问题。**

+ **可重复读(RR)**:一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。

  > RR 隔离级别下，普通的 select 使用快照读(snapshot read)，底层使用 MVCC 来实现
  >
  > 加锁的 select(select ... in share mode / select ... for update)以及更新操作update, delete 等语句使用当前读（current read），底层使用记录锁、或者间隙锁、临键锁。

+ **串行化(S)**:顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

  > Serializable 所有的 select 语句都会被隐式的转化为 select ... in share mode，会和update、delete 互斥。

| 级别     | symbol           | 值   | 描述                                                         |
| -------- | ---------------- | ---- | ------------------------------------------------------------ |
| 读未提交 | READ-UNCOMMITTED | 0    | 存在脏读、不可重复读、幻读的问题                             |
| 读已提交 | READ-COMMITTED   | 1    | 解决脏读的问题，存在不可重复读、幻读的问题                   |
| 可重复读 | REPEATABLE-READ  | 2    | mysql 默认级别，解决脏读、不可重复读的问题，存在幻读的问题。使用 MMVC机制 实现可重复读 |
| 序列化   | SERIALIZABLE     | 3    | 解决脏读、不可重复读、幻读，可保证事务安全，但完全串行执行，性能最低 |

##### REPEATABLE-READ问题

+ B事务在A事务进行第一次select前修改某个数据(id=p)并提交，A事务是查询(select)到修改后的数据

| Session A                                                    | Session B                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| START TRANSACTION;                                           | START TRANSACTION;                                           |
|                                                              | update student set title='CR' where id=12; (在此之前title值不为CR) |
|                                                              | COMMIT;                                                      |
| select * from student where id=12;    （可以看到B修改的title值）ReadView第一次生成 |                                                              |

+ B事务在A事务进行过程中插入新数据(id=p)并提交，虽然A事务是查询(select)不到新数据，但A事务想插入相同新数据(id=p)时却失败了（明明查询显示没有，但却插入失败，报错提示记录id重复）

  >  select * from student **LOCK IN SHARE MODE**; 
  >
  >  select * from student **FOR UPDATE**;
  >
  >  InnoDB提供了这样的机制，在默认的可重复读的隔离级别里，可以使用加锁读去查询最新的数据，如果使用加锁读，是可以读到其他事务中已提交的新增insert数据或delete掉的数据。

| Session A                                                    | Session B                            |
| ------------------------------------------------------------ | ------------------------------------ |
| START TRANSACTION;                                           | START TRANSACTION;                   |
| SELECT * FROM student;  （>>empty set）                      |                                      |
|                                                              | INSERT INTO student VALUES (1, 'a'); |
| SELECT * FROM student;    (>>empty set)                      |                                      |
| INSERT INTO student VALUES (1, 'a');  (>>ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction)  阻塞被锁住，等待一段时间后报错 |                                      |
|                                                              | COMMIT;                              |
| SELECT * FROM student;    (>>empty set)                      |                                      |
| INSERT INTO student VALUES (1, 'a');  (>>Duplicate entry '1' for key 'PRIMARY')  插入失败 |                                      |

+ 事务B事务中A进行过程中插入新数据(id=p)并提交，虽然A事务是查询(select)不到新数据，但A事务进行更新操作时(update/delete)是可以对看不到的新数据(id=p)产生影响的，当A事务对(id=p)新数据进行update时(必须某个值和原来的记录不一样，否则再次查询还是没有多出数据的)，再次查询数据发现多出了一条数据；当A事务对(id=p)新数据进行delete，是会把新数据(id=p)删掉的(A事务提交后)

| Session A                                                    | Session B                            |
| ------------------------------------------------------------ | ------------------------------------ |
| START TRANSACTION;                                           | START TRANSACTION;                   |
| SELECT * FROM student;  （>>empty set）                      |                                      |
|                                                              | INSERT INTO student VALUES (1, 'a'); |
| SELECT * FROM student;    (>>empty set)                      |                                      |
| UPDATE student SET value='b' ;   (>>ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction)  阻塞被锁住，等待一段时间后报错 |                                      |
|                                                              | COMMIT;                              |
| SELECT * FROM student;    (>>empty set)                      |                                      |
| UPDATE student SET value='b'  ;   (>>Rows matched: 1 Changed: 1 Warnings: 0)    **将所有行值替换为b,这会影响到id=1的数据，虽然当前事务并不知道id=1数据的存在；由于value=b和原来value=a不同，则更新成功** |                                      |
| SELECT * FROM student;    (>>多出了更新后的记录，但之前并没插入过) |                                      |

+ 事务B事务中A进行第一次select后过程中删除掉某个数据(id=p)并提交，A事务是可以查询(select)到数据(id=p)，但A事务对数据(id=p)进行update/delete操作时完全不起作用，使用select依旧可以查询到数据(id=p)



### InnoDB的锁类型

锁是为了解决资源竞争的问题，数据库的资源就是数据表或者数 据行，锁是用来解决事务对数据的并发访问的问题的。InnoDB的行锁锁定的是索引，而不是记录本身，索引相同的记录都会被加锁，会造成索引竞争，这就需要我们严格设计业务sql，尽可能的使用主键或唯一索引对记录加锁。索引映射的记录如果存在，加行锁，如果不存在，则会加 next-key lock / gap 锁 / 间隙锁，故InnoDB可以实现事务对某记录的预先占用，如果记录存在，它就是本事务的，如果记录不存在，那它也将是本是无的，只要本是无还在，其他事务就别想占有它。

> 如果我们定义了主键(PRIMARY KEY)，那么 InnoDB 会选择主键作为聚集索引。
>
> 如果没有显式定义主键，则 InnoDB 会选择第一个不包含有 NULL 值的唯一索引作为主键索引。
>
> 如果也没有这样的唯一索引，则 InnoDB 会选择内置 6 字节长的 ROWID 作为隐藏的聚集索引，它会随着行记录的写入而主键递增。

主键索引：存储索引和数据

辅助索引：存储索引和主键

##### 共享锁(读锁)

共享锁(Shared Lock)：也叫读锁(X)，一个事务获取了一行数据的读锁之后，其他的事务可以再次获取查询数据，需要注意的是：不要在加上了读锁以后去写数据，不然的话可能会出现死锁的情况。释放锁有两种方式，只要事务结束，锁就会自动释放事务，包括提交事务和结束事务。如果一个事务对某一行数据加了S锁，另一个事务还可以对相应的行加S锁，但是不能对相应的行加X锁。 共享锁的作用通常用于在事务中读取一条行记录后，不希望它被别的事务锁修改，但所有的读请求产生的LOCK_S锁是不冲突的。

> select  *  from  student  **lock in share mode**

##### 排他锁(写锁)

排他锁(Exclusive Lock)：也叫做写锁(X)，它是用来操作数据的，所以又叫做写锁。只要一个事务获取了一行数据的排它锁，其他的事务就不能再获取这一行数据的共享锁和排它锁。排它锁的加锁方式有两种，第一种是自动加排他锁。我们在操作数据的时候，包括增删改，都会默认加上一个排它锁。还有一种是手工加锁，我们用一个 FOR UPDATE 给一行数据加上一个排它锁，这个无论是在我们的代码里面还是操作数据的工具里面，都比较常用。如果一个事务对某一行数据加了X锁，另一个事务既不能对相应的行加S锁也不能加X锁。 排他锁的目的主要是避免对同一条记录的并发修改。通常对于UPDATE或者DELETE操作，或者类似SELECT … FOR UPDATE操作，都会对记录加排他锁。 

> select   *  from  student  **for update**

##### 记录锁

记录锁(Record Lock)：记录锁锁定索引中一条记录。在 RC 隔离级别下一般加的都是该类型的记录锁

##### 间隙锁

间隙锁(Gap Lock)：表示只锁住一段范围，不锁记录本身，通常表示两个索引记录之间，或者索引上的第一条记录之前，或者最后一条记录之后的锁。可以理解为一种区间锁，一般在RR隔离级别下会使用到GAP锁。

##### 意向锁

意向锁(Intention Lock)：意向锁是一种表级锁，锁的粒度是整张表，分为意向共享锁（IS）和意向排它锁（IX）。引入意向锁的目的：在于在定位到特定的行所持有的锁之前，提供一种更粗粒度的锁，可以大大节约引擎对于锁的定位和处理的性能，因为在存储引擎内部，锁是由一块独立的数据结构维护的，锁的数量直接决定了内存的消耗和并发性能。例如，事务A对表t的某些行修改（DML通常会产生X锁），需要对t加上意向排它锁，在A事务完成之前，B事务来一个全表操作（alter table等），此时直接在表级别的意向排它锁就能告诉B需要等待（因为t上有意向锁），而不需要再去行级别判断。 

##### next-key

next-key 锁包含两部分：记录锁和间隙锁，记录锁是加在索引上的锁，间隙锁是加在索引之间的；其原理是将当前数据行与上一条数据和下一条数据之间的间隙锁定，保证此范围内读取的数据是一致的。

### MVCC



https://zhuanlan.zhihu.com/p/64576887

多版本并发控制是通过保存数据快照来实现的，事务每次取数据的时候都会取创建版本小于当前事务版本的数据，以及过期版本大于当前版本的数据。普通的 select 就是快照读。其原理是：将历史数据存一份快照，所以其他事务增加与删除数据，对于当前事务来说是不可见的。`MVCC` 在读已提交`（Read Committed）`和可重复读`（Repeatable Read）`隔离级别下起作用。`InnoDB` 中 `MVCC` 的实现方式为：每一行记录都有两个隐藏列：`DATA_TRX_ID`、`DATA_ROLL_PTR`（如果没有主键，则还会多一个隐藏的主键列）。

+ DATA_TRX_ID：记录最近更新这条行记录的事务 ID，大小为 6 个字节
+ DATA_ROLL_PTR：表示指向该行回滚段（rollback segment）的指针，大小为 7 个字节，InnoDB 便是通过这个指针找到之前版本的数据。该行记录上所有旧版本，在 undo 中都通过链表的形式组织。
+ DB_ROW_ID：行标识（隐藏单调自增 ID），大小为 6 字节，如果表没有主键，InnoDB 会自动生成一个隐藏主键，因此会出现这个列。另外，每条记录的头信息（record header）里都有一个专门的 bit（deleted_flag）来表示当前记录是否已经被删除。

| COLUMN 1 | COLUMN 2 | ...  | **DATA_TRX_ID** | **DATA_ROLL_PTR** | **DB_ROW_ID** |
| -------- | -------- | ---- | --------------- | ----------------- | ------------- |
|          |          |      | 递增            | 指向向上一版本    |               |

在 RC 隔离级别下，每个 SELECT 语句开始时，都会重新将当前系统中的所有的活跃事务拷贝到一个列表生成 ReadView。

在 RR 隔离级别下，每个事务 touch first read 时（本质上就是执行第一个 SELECT 语句时，后续所有的 SELECT 都是复用这个 ReadView，其它 update, delete, insert 语句和一致性读 snapshot 的建立没有关系），会将当前系统中的所有的活跃事务拷贝到一个列表生成ReadView。

二者的区别就在于生成 ReadView 的时间点不同，一个是事务之后第一个 SELECT 语句开始、一个是事务中每条 SELECT 语句开始。

### 死锁

##### 死锁条件

+ 互斥：锁本身是互斥的，同一时刻只能有一个事务持有这把锁
+ 请求与保持：某个事务拿到锁之后，又去请求另一个锁
+ 不可剥夺：其他的事务需要在这个事务释放锁之后才能获取锁，不可强行剥夺
+ 循环等待：当多个事务形成等 待环路的时候，即发生死锁

##### 查看锁信息

show status like 'innodb_row_lock_%'；

> Innodb_row_lock_current_waits：当前正在等待锁定的数量；
>
> Innodb_row_lock_time ：从系统启动到现在锁定的总时间长度，单位 ms；
>
> Innodb_row_lock_time_avg ：每次等待所花平均时间；
>
> Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间；
>
> Innodb_row_lock_waits ：从系统启动到现在总共等待的次数。

 select * from information_schema.innodb_trx\G;     

> 查看当前运行的所有事务

##### 避免死锁

1. 在程序中，操作多张表时，尽量以相同的顺序来访问（避免形成等待环路）
2.  批量操作单张表数据的时候，先对数据进行排序（避免形成等待环路）；
3. 申请足够级别的锁，如果要操作数据，就申请排它锁；
4. 尽量使用索引访问数据，避免没有 where 条件的操作，避免锁表；
5. 如果可以，大事务化成小事务；
6. 使用等值查询而不是范围查询查询数据，命中记录，避免间隙锁对并发的影响。



在高并发数据库系统中，需要保证事务与事务之间的隔离性，还有事务本身的一致性。

RR 级别作为 mysql 事务默认隔离级别（20%的事务存在幻读的可能，80%的事务没有幻读的风险）SERIALIZABLE 级别则是悲观的认为幻读时刻都会发生，故会自动的隐式的对事务所需资源加排它锁，其他事务访问此资源会被阻塞等待，故事务是安全的，但需要认真考虑性能。



### Spring事务

编程式事务

声明式事务



##### 传播特性

当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行

+ PROPAGATION_NEVER：当前方法以非事务方式执行(失败不回滚)，当上一级存在事务时则抛出异常
+ PROPAGATION_NOT_SUPPORTED：当前方法以非事务方式执行(失败不回滚)，当上一级存在事务时就将它挂起直到当前方法执行完毕（这可能会造成死锁，被挂起的事务先锁数据然后当前方法需要访问同一数据）



+ PROPAGATION_SUPPORTS：如果上级有事务，当前方法就和上级使用同一事务（只要有一个发生错误回滚，另一个也会回滚）；如果上级没有事务，当前方法就以非事务方式执行。



+ PROPAGATION_REQUIRED_NEW：表示当前方法运行在自己创建的新事务中。如果上级存在当前事务，那么当前方法执行期间，上级事务会被挂起。两者互不影响，完全隔离

+ PROPAGATION_REQUIRED(默认)：如果上级没有事务，当前方法就新建一个事务；如果上级有事务，则加入到上级事务中；两者互相影响，任意一回滚都导致另一个回滚
+ PROPAGATION_NESTED：如果上级有事务，则当前方法的事务会嵌套在上级事务中执行（上级影响当前方法，但当前方法不影响上级）。如果上级没有事务，则当前方法会新建自己的事务
+ PROPAGATION_MANDATORY：如果上级没有事务，则会抛出一个异常；如果上级有事务则使用同一个事务；两者互相影响


