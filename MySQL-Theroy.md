### MySQL架构

MySQL是一个单进程多线程架构的数据库，其数据库实例在系统上的表现是一个进程。

+ 数据库(database)：数据库是文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合（数据库是由一个个文件组成的，通常是二进制文件，存储在文件系统上）
+ 实例(instance)：数据库实例是程序，是位于用户与操作系统之间的一层数据管理软件，用户对数据库数据的任何操作，包括数据库定义、数据查询、数据维护、数据库运行控制等都是在数据库实例下进行的，应用程序只有通过数据库实例才能和数据库打交道。（要想对数据库文件进行SELECT、INSERT、UPDATE和DELETE之类的操作必须通过数据库实例来完成）

在MySQL中，数据库实例是用来操作数据库文件的，实例与数据库通常是一一对应的

![mysql架构](\image\mysql架构.png)

MySQL主要由如下四层组成：

+ 网络连接层（Client Connectors）：主要负责连接管理、授权认证、安全等等。每个客户端连接都对应着服务器上的一个线程。服务器上维护了一个线程池，避免为每个连接都创建销毁一个线程。当客户端连接到 MySQL 服务器时，服务器对其进行认证。可以通过用户名与密码认证，也可以通过 SSL 证书进行认证。登录认证后，服务器还会验证客户端是否有执行某个查询的操作权限。
+ 服务层（MySQL SERVER）：MySQL 的核心服务层都在这一层，查询解析，SQL 执行计划分析，SQL 执行计划优化，查询缓存。以及跨存储引擎的功能都在这一层实现：存储过程，触发器，视图等
  + 连接池（Connection Pool）：管理、缓冲用户的连接，线程处理等需要缓存的需求。
  + 管理服务和工具组件（Services & utilities）：系统管理和控制工具，例如备份恢复、MySQL 复制、集群等。
  + SQL接口（SQL Interface）：接受用户的 SQL 命令，并且返回用户需要查询的结果。
  + 查询分析器（Parser）：SQL 命令传递到解析器的时候会被解析器验证和解析（权限、语法结构）。
  + 优化器（Optimizer）：SQL 语句在查询之前会使用查询优化器对查询进行优化。
  + 缓冲（Caches）：如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。
+ 存储引擎层（Pluggable Storage Engines）：负责 MySQL 中数据的存储与提取。 服务器中的查询执行引擎通过 API 与存储引擎进行通信，通过接口屏蔽了不同存储引擎之间的差异。MySQL 采用插件式的存储引擎。MySQL 为我们提供了许多存储引擎，每种存储引擎有不同的特点。我们可以根据不同的业务特点，选择最适合的存储引擎。如果对于存储引擎的性能不满意，可以通过修改源码来得到自己想要达到的性能。（存储引擎是基于表，而不是数据库，一个库中不同表可以使用不同的存储引擎，服务器通过 API 与存储引擎进行通信，用来屏蔽不同存储引擎之间的差异。）
+ 系统文件层：系统文件层包含数据、索引、redo 日志、undo 日志、错误日志、查询记录、慢查询等物理文件

一个MySQL实例对应多个Database，每个Database有一个Schema，每个Schema下可以有多张表，基于表可以建立很多虚拟视图

#### MySQL连接

连接MySQL即是一个连接进程和MySQL数据库实例进行通信，即进程通信(常用的进程通信方式有管道、命名管道、TCP/IP套接字、UNIX域套接字)在通过TCP/IP连接到MySQL实例时，MySQL会先查询一张权限视图(mysql下的user表)，用来判断发起请求的客户端IP是否允许连接到MySQL实例

+ 管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
+ 命名管道（FIFO）：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
+ 消息队列（MessageQueue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
+ 共享存储（SharedMemory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
+ 信号量（Semaphore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
+ 套接字（Socket）：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
+ 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

```mysql
use mysql;
SELECT host,user FROM user;
```

#### InnoDB存储引擎

InnoDB的设计目标主要是面向在线事务处理（OLTP）的应用。其特点是支持事务、行锁设计、支持外键。每张表的数据会单独存放到一个独立的 .idb文件中。

InnoDB通过使用多版本并发控制（MVCC）来获得高并发性，并实现了SQL标准的4中隔离级别，默认为REPEATABLE级别。通过使用一种被称为next-key-locking的策略来避免幻读（phantom）现象的产生。出此之外，InnoDB存储引擎还提供了插入缓冲(insert buffer)、二次写(double write)、自适应哈希索引(adaptive hash index)、预读(read ahead)等高性能和高可用的功能。

对于表中的数据存储，InnoDB引擎采用了聚集(clustered)的方式，因此每张表的存储都是按主键的顺序进行存放。如果没有显示的在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID, 并以此作为主键和聚集索引。除了ROWID外，其实每行还有一个6字节的事务ID (DB_TRX_ID) 和一个7字节的回滚指针 (DB_ROLL_PTR) ，事务ID为当前事务的ID号，用于实现MVCC，回滚指针指向一个（包含了恢复到之前状态所需的所有信息）地址。

#### MyISAM存储引擎

MyISAM不支持事务、表锁设计，主要面向OLAP数据库应用。MyISAM的缓冲池只缓存索引文件，而不缓冲数据文件。MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。

#### Memory存储引擎

Memory将数据存放在内存中，如果数据重启或发生崩溃，表中的数据都将消失。它非常适合用于存储临时数据的临时表。Memory默认使用hash索引，只支持表锁，不支持TEXT和BLOB列类型

#### 文件

##### 参数文件

参数配置文件指明数据库各种文件所在位置以及指定某些初始化参数，这些参数通常定义了某种内存结构的的信息

##### 日志文件

日志文件记录了影响MySQL数据库的各种类型活动。MySQL数据库中常见的日志文件有

+ 错误日志(error log)：记录了MySQL启动、运行、关闭过程中出现的错误信息，一些警告或正确的信息也会被记录下来

  > show variables like 'log_error'

+ 二进制日志(binlog)：记录了对数据库执行更改的所有操作（不包括select和show这类的操作）

  + 恢复(recovery)：某些数据的恢复需要二进制日志(例如在一个数据库全备文件恢复后，用户可以通过二进制日志进行point-in-time的恢复)
  + 复制(replication)：通过复制和执行二进制日志使一台远程MySQL数据库(slave)与另一台MySQL数据库(master)进行数据同步
  + 审计(aduit)：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入的攻击

  > show variables like 'log_bin';

+ 慢查询日志(slow query log)：将运行时间超过阈值(long_query_time)的SQL会被记录到该日志中，可以帮助定位SQL优化

  > show variables like 'long_query_time' 

  可以通过设置慢日志输出参数将慢查询日志记录到一张表(mysql.slow_log，该表使用的存储引擎为CSV)中

  > show variables like 'log_output
  >
  > set global log_output='TABLE';
  >
  > show create table mysql.slow_log

+ 查询日志(log)：查询日志记录了所有对MySQL数据库请求的信息，无论这些请求是否得到了正确的执行。(默认是关闭的)

  > show variables like '%general%'

##### pid文件

当MySQL实例启动时，会将自己的进程ID写入一个文件中，文件名为主机名.pid

>  show variables like 'pid_file'

##### MySQL表结构文件

MySQL数据的存储是根据表进行的，每个表都会有与之对应的文件，文件已.frm为后缀名，这个文件记录了该表的表结构定义

> https://blog.csdn.net/n88Lpo/article/details/95118434

> （在MySQL 8.0后frm文件被取消了，并采用 Serialized Dictionary Information (SDI), 是MySQL8.0重新设计数据词典后引入的新产物,并开始已经统一使用InnoDB存储引擎来存储表的元数据信息。SDI信息源记录保存在ibd文件中。 如何可以查看表结构信息，官方提供了一个工具叫做ibd2sdi，在安装目录下可以找到，可以离线的将ibd文件中的冗余存储的sdi信息提取出来，并以json的格式输出到终端。 用法示例：）
>
> Oracle 将FRM文件的信息及更多信息移动到叫做序列化字典信息（Serialized Dictionary Information，SDI），SDI被写在ibd文件内部，它是数据字典包含的信息的一个冗余副本。
>
> 表空间中表的DDL操作会更新修改SDI。这就是：如果正常一个表一个文件，那么这个文件就只有这张表的SDI，但是如果是多个表在一个表空间，那么SDI信息是表空间中所有的表的。
>
> 为了从IBD文件中提取SDI信息，Oracle提供了一个应用程序 ibd2sdi。此应用程序解析SDI信息，并以JSON文件输出，该JSON文件便于操作提取和构建表定义。
>
> 分区表的SDI是个例外。分区表的SDI信息只存在于第一个分区，如果你删除第一个分区，SDI信息会移动到下一个分区。稍后展示。

### InnoDB

InnoDB是OLTP应运用中核心表的首选存储引擎，其特点是完整支持ACID事务、行锁设计、支持MVCC、支持外键、提供一致性非锁定读。在某些站点上InnoDB处理插入/更新操作的速度平均为800次/秒

#### 体系架构

​		InnoDB是多线程的模型，包含多个后台线程，后台线程的主要作用是负责刷新内存池中的数据，保证缓冲池的内存缓存的是最近的数据，此外将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态。后台线程主要有Master Thread、IO Thread、Purge Thread、Page Cleanner Thread

+ Master Thread：负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包含合并插入缓冲（INSERT BUFFER）
+ IO Thread：在InnoDB存储引擎中大量使用了AIO（Async IO）来处理写IO请求，而IO Thread的工作主要是负责这些IO请求的回调（4个read thread、4个write thread、insert buffer thread、log thread）
+ Purge Thread：在事务提交后会回收已经使用并分配的undo页
+ Page Cleanner Thread：将之前版本中脏页的刷新操作都放入到单独的线程中来完成

InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理，但CPU与磁盘之间的读写存在鸿沟，所以需要使用缓冲池的速度来提高数据库的整体性能，缓冲池是一块内存区域。在进行读页操作时，首先将从磁盘读到的页存放在缓冲池中，下一次再读相同页时，首先判断该页是否存在缓冲池中，若在缓冲池中，则直接读取该页，否则读取磁盘上的页。在进行修改操作时，首先修改缓冲池中的页，然后再以一定的频率刷新到磁盘中(以一种Checkpoint的机制刷新回磁盘)

缓冲池主要缓存索引页和数据页，还包括其他undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等。

+ 维护所有进程/线程需要访问的多个内部数据结构
+ 缓存磁盘上的数据，方便快速地读取，同时在对磁盘文件的数据修改之前在这里缓存
+ 重做日志(redo log)缓冲

```mysql
SHOW VARIABLES LIKE 'innodb_%io_threads';
SHOW ENGINE INNODB STATUS;
SHOW VARIABLES LIKE 'innodb_purge_threads';
SHOW VARIABLES LIKE 'innodb_buffer_pool_size;
```

```mysql
use information_schema;
select * from innodb_buffer_pool_stats;
```

##### 缓冲池管理

+ LRU(Latest Recent Used，最近最少使用)：将最频繁使用的页放在LRU前端，最少使用的页放在LUR列表尾端；当缓冲池不能存放新读取到的页时，首先释放LRU列表尾端的页。

  在Innodb中，在LRU列表中加入了midpoint(37%)位置，新读取的页放在midpoint的位置，midpoint之前的页时最为活跃的热点数据

  > show variables like 'innodb_old_blocks_pct'

  使用midpoint的原因是某些SQL操作(一些索引或数据扫描)可能会使得缓冲池中所有页被刷出，这样会影响缓冲池的效率。这些操作可能需要访问表中的许多页，但这些页仅仅是在这次查询中使用到，并不是热点数据；如果这些页被放在LRU列表的首部，那么很有可能会将之前的热点数据页从LRU列表中移除，这样导致下次读取热点数据页要重新从磁盘里读取。另外在mid位置的页如果等待一段时间(innodb_old_blocks_time)后还存在，那么表名这些页算是热点数据，这时innodb会把这些页移到LRU列表的热端

  > show variables like 'innodb_old_blocks_time'

+ Free列表：LRU列表是用来管理已读取的页，一开始，数据库刚启动时，页时存放在Free列表中的，当需要从缓冲池中分页时，先从Free列表中查找是否有可用的空闲页，若有则将该页从Free列表中删除，放入LRU列表中；否则，根据LRU算法，淘汰LRU列表末尾的页，将内存空间分配给新的页。

+ Flush列表：在LRU列表中的页被修改后的页被称为脏页(即缓冲池中的页和磁盘上数据不一致)，脏页会存放到Flush列表中，通过CHECKPOINT机制定时将页面刷新回磁盘。脏页既存在于LRU列表中，也存在于Flush列表中。LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘

##### 重做日志缓冲

Innodb首先会将重做日志(redo log)放入重做日志缓冲(redo log buffer)，然后以一定的频率将其刷新到重做日志。从重做日志缓冲往磁盘写入时，是按512个字节，也就是一个扇区的大小，因为扇区是写入的最小单位，因此可以保证写入必定是成功的。

> show variables like 'innodb_log_buffer_size'

通常会在一下三种情况下将重做日志缓冲的内容刷新到外部磁盘的重做日志中

+ Master Thread每一秒将重做日志缓冲刷新到重做日志文件
+ 每个事务提交时将重做日志缓冲刷新到重做日志文件
+ 当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件

 缓冲池的设计目的是为了协调CPU速度与磁盘速度的鸿沟，页的操作首先是在缓冲池中完成的，因此，在执行DML语句，如Update、Delete时，缓冲中的页是比磁盘中的更新的，那么数据库需要将新页从缓冲池刷新到磁盘中。在事务提交时，先写重做日志，再修改页，那么即使数据库宕机时丢失的数据，也可以通过重做日志来完成数据恢复，这就是ACID中持久性(Durability)的要求

##### Checkpoint

Checkpoint机制用于将缓冲池中的脏页刷新回磁盘，其目的是解决以下几个问题

+ 缩短数据库的恢复时间：当数据库发生宕机时，数据库不需要重做所有日志，因为Checkpoint之前的页都已经刷新回到磁盘。所以数据库只需对Checkpoint后的重做日志进行恢复
+ 缓冲池不够用时，将脏页刷新到磁盘中：当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，那么需要强制执行Checkpoint，将脏页也就是页的新版本刷回磁盘
+ 重做日志不可用时，刷新脏页：重做日志是循环使用的，不需要的部分可以被覆盖重用。当重做日志可用部分已满时，必须先将部分的页刷新回磁盘，使得重做日志中的部分记录可以被覆盖。

##### 表空间文件

Innodb采用将存储的数据按表空间(tablespace)进行存放的顺序。在默认配置下会有一个初始大小为10MB，名为ibdata1的表空间文件。所有基于InnoDB存储引擎的表的数据都会记录到该共享表空间中。若设置innodb_file_per_table，则每个表会产生一个独立的表空间文件（表名.idb），这些单独的文件仅存储该表的数据、索引和插入缓冲BITMAP等信息，其余信息还是存放在默认的表空间中

> show variables like 'innodb_data_file_path'

> show variables like 'innodb_file_per_table'

##### 重做日志文件

默认情况下，InnoDB的数据目录下会有两个名为ib_logfile0和ib_logfile1的重做日志文件(redo log file)，他们记录了对于InnoDB存储引擎的事务日志。当数据宕机时，可以利用重做日志将数据恢复到宕机前的状态，以此来保证数据的完整性。每个innodb至少有1个重做日志文件组，每个文件组下至少有两个重做日志文件，并且还可以设置多个镜像日志组，将不同的文件组放在不同的磁盘上以此提高重做日志的高可用性。在日志组中每个重做日志文件的大小一致，并以循环写入的方式运行，当一个重做日志文件写满时，切换到另一个重做日志文件。

> show variables like 'innodb%log%'

+ innodb_log_file_size：每个重做日志的大小

+ innodb_log_files_in_group：日志文件组中重做日志文件的数量，默认为2

+ innodb_log_group_home_dir：重做日志组所在路径

+  innodb_flush_log_at_trx_commit：控制在事务提交时，处理重做日志的方式

  > 0：表示当事务提交时，并不会将事务的重做日志写入磁盘的日志文件中，而是等待主线程每秒的刷新
  >
  > 1：表示在执行commit时将重做日志缓冲同步写到磁盘（为了保证持久性必须设为1，确保提交的事务都已写入重做日志文件）
  >
  > 2：表示将重做日志异步写到磁盘，即写到文件系统的缓存中（不能保证肯定会写入重做日志）

二进制日志与重做日志的区别

+ 二进制会记录所有与MySQL数据库有关的日志记录，包括InnoDB、MyISQM、Heap等其他存储引擎的日志；而重做日志只记录InnoDB相关的事务日志
+ 二进制日志记录的是关于一个事务的具体操作内容，即该日志为逻辑日志；而重做日志记录的是关于每个页的更改的物理情况
+ 二进制日志仅在事务提交前进行提交，即只写磁盘一次。而重做日志在事务进行过程中也会不断地写入重做日志文件中

#### 表

在InnoDB中，表是根据主键顺序组织存放的，每张表都会有个主键（Primary Key），如果创建表时没有显式地定义主键，则InnoDB存储引擎会先判断表中是否有非空的唯一索引(Unique NOT NULL)，如果有(有多个非空唯一索引时，会选择建表时第一个定义的非空唯一索引为主键)，则以该列为主键；如果以上条件均不符合，则InnoDB会自动创建一个6字节大小的指针。通过查询_rowid可以显示表的主键

### OLTP/OLAP

### InnoDB性能因素

重做日志文件大小(过大恢复时间过长，过小会导致一个事务的日志需要多次切换重做日志文件，而且会频繁发生async checkpoint，导致性能抖动)