+ 高并发：瞬时流量增大，直接访问数据库会蹦掉。

  + 前端：将前端的资源静态化，前端使用自己的服务器；前端限流，按钮置灰，防止用户提前发起大量请求，每次按下后重新置灰短暂时间，降低用户请求数

  + 后端使用redis做缓存，提前把商品的库存加载到Redis中，Redis就有一个问题了，我们上面说了我们采用主从，就是我们会去读取库存然后再判断然后有库存才去减库存，比如现在库存只剩下1个了，我们高并发嘛，4个服务器一起查询了发现都是还有1个，那大家都觉得是自己抢到了，就都去扣库存，那结果就变成了-3

    但单机redis的QPS只有几万(3~4w)，如果访问流量大，可以使用集群，主从同步、读写分离，我们还搞点哨兵，开启持久化实现高可用；实在不行，使用多台服务器，使用Nginx用作负载均衡

    

    我们卖1000件商品，请求有10W，我们不需要把十万都放进来，你可以放1W请求进来，然后再进行操作，因为秒杀对于用户本身就是黑盒的，所以你怎么做的他们是没感知的，至于为啥放1W进来，而不是刚好1000，是因为会丢掉一些薅羊毛的用户，至于怎么判断，后面的风控阶段我会说。所有措施还是拦不住很多羊毛党，因为他们是专业的团队，他们可以注册很多账号来薅你的羊毛，而且不用机器请求，就用群控，操作几乎跟真实用户一模一样。在请求到达后端之前，风控可以根据账号行为分析出这个账号机器人的概率大不大，只能通杀了，通杀的意思就是，我们通过风管分析出来这个用户是真实用户的概率没有其他用户概率大，那就认为他是机器了，丢弃他的请求。因为秒杀本来就是黑盒操作的，用户层面是无感知的，这样设计能让真实的用户买到东西，还可以减少自己被薅羊毛的概率。

  + 数据库：数据库用MySQL只要连接池设置合理一般问题是不大，单独给秒杀建立一个数据库，为秒杀服务，表的设计也是竟可能的简单点，现在的互联网架构部署都是分库的。至于表就看大家怎么设计了，该设置索引的地方还是要设置索引的，建完后记得用explain看看SQL的执行计划。

Tomcat只能顶几百的并发，mysql的并发大概为500-1000，单机redis的QPS只有几万

+ 恶意请求：单个用户请求次数太多，使用网关拦截
+ 超卖：多卖出去
+ 链接暴露：暴露请求地址(可能是通过网页开发者模式)，非用户请求。使用动态url,对url进行加密，通过后端校验可以

限流→降级→熔断→隔离：不怕一万就怕万一，万一你真的顶不住了，限流，顶不住就挡一部分出去但是不能说不行，降级，降级了还是被打挂了，熔断，至少不要影响别的系统，隔离，你本身就独立的，但是你会调用其他的系统嘛，你快不行了你别拖累兄弟们啊

削峰填谷：放到消息队列，然后一点点消费去改库存就好了嘛，不过单个商品其实一次修改就够了





上面的任何一步都是可能出错的，而且我们是在不同的服务里面出错的，那就涉及分布式事务了，但是分布式事务大家想的是一定要成功什么的那就不对了，还是那句话，几个请求丢了就丢了，要保证时效和服务的可用可靠。