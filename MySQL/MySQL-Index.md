## mysql index

> SELECT DISTINCT
> ​		<select_list>
> FROM
> ​		<left_table>  <join_type>  JOIN  <right_table>  ON  <join_condition>
> WHERE
> ​		<where_condition>
> GROUP BY
> ​		<group_by_list>
> HAVING
> ​		<having_condition>
> ORDER BY
> ​		<order_by_condition>
> LIMIT 
> ​		<limit_number>

+ SQL执行顺序

> FROM <left_table>
> ON <join_condition>
> <join_type>  JOIN  <right_table>
> WHERE <where_condition>
> GROUP BY <group_by_list>
> HAVING <having_condition>
> SELECT
> DISTINCT <select_list>
> ORDER BY <order_by_condition>
> LIMIT <limit_number>

+ 查看所有数据库的列数

  > select count(*) from information_schema.columns;

+ 查看某个数据库的列数

  > select count(*) from information_schema.columns where table_schema='库名';

+ 查看某个数据库某个表的列数

  > select count(*) from information_schema.columns where table_schema='库名' and table_name='表名';

+ 查看mysql中哪些表没有建索引

  > select  *  from information_schema.tables as t left join (select distinct table_schema, table_name from information_schema.KEY_COLUMN_USAGE) as kt on kt.table_schema=t.table_schema and kt.table_name= t.table_name where t.table_schema not in('mysql','information_schema','performance_schema','test','sys')  and  kt.table_name is null ;

数据结构：B-树（所有节点都存储数据）、B+树（只有叶子节点存储数据，非叶子节点只存储key）

MyISAM主(唯一)索引：叶子节点储存数据的地址（key唯一性，根据地址只找到一条数据）

MyISAM辅助索引：叶子节点存储数据的地址(key可重复，根据地址可能找到多条数据)

InnoDB主(唯一)索引：叶子节点直接储存数据记录（占用空间较大）

InnoDB二级索引：叶子节点存储主键，然后根据主键再去找主索引的数据

> show index from student
>
> alter table student add index  age_index(age)  //为age字段建立索引
>
> ALTER TABLE student ADD UNIQUE(id)   //为id建立唯一索引  
>
> create index name_index on student(name)  //为name字段建立普通索引
>
> create unique index name_index on student(name)  //为name建立唯一索引
>
> drop index name_index on student  //删除name_index索引
>
> alter table student drop primary key  //去除主键（前提主键无自增）
>
> alter table student change id in int //修改id的类型(非自增)再删除主键

### 索引

索引的目的在于提高查询效率，原理是通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把**随机的事件变成顺序的事件**，也就是我们总是通过同一种查找方式来锁定数据。

> 等值查询，还有范围查询(>、<、between、in)、模糊查询(like)、并集查询(or)

把数据分成段，然后分段查询，访问磁盘的成本大概是访问内存的十万倍左右

​		磁盘IO和预读，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右。一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。

​		考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。

MySQL的数据实际是存储在文件中，而磁盘IO的查找速度是要远小于内存速度的，所以减少磁盘IO的次数能很大程度的提高MySQL性能。

磁盘IO时间 = 寻道 + 磁盘旋转 + 数据传输时间

从磁盘读取数据时，系统会将逻辑地址发给磁盘，磁盘将逻辑地址转换为物理地址（哪个磁道，哪个扇区）。 磁头进行机械运动，先找到相应磁道，再找该磁道的对应扇区，扇区是磁盘的最小存储单元

机械硬盘的连续读写性能很好，但随机读写性能很差。

- 顺序访问：内存访问速度是硬盘访问速度的6~7倍（`kafka`的特点，以后有机会的话再讲一讲）
- 随机访问：内存访问速度就要比硬盘访问速度快上10万倍以上

随机读写时，磁头需要不停的移动，时间都浪费在了磁头寻址上。 而在实际的磁盘存储里，是很少顺序存储的，因为这样的维护成本会很高。

为了将每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级，B+树应运而生

![B+树](..\image\B+树.jpg)

​		每个节点是一个磁盘块，每个磁盘块包含几个数据项以及指向下一个磁盘块的指针，非叶子节点不存储真实的数据，只存储指引搜索方向的数据项(即非叶子节点的键值可能实际数据表中并不存在该键值)，真实的数据存在于叶子节点。如果要查找某个一个数据(29)，那么首先会把根节点的磁盘块由磁盘加载到内存，此时发生**一次**IO，在内存中用**二分查找**确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第**二次**IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生**第三次**IO，同时内存中做二分查找找到29，结束查询，总计三次IO。**真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高**。

​		IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的(每个磁盘块大小为4K)，如果数据项(索引数目及大小)占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。

> 1. B+树索引并不能直接找到行，只是找到行所在的页，通过把整页读入内存，再在内存中查找。
> 2. 索引的B+树高度一般为2-4层，查找记录时最多只需要2-4次IO。

索引(index)是帮助mysql高效获取数据的一种数据结构（排好序的快速查找数据结构），以某种方式指向数据。索引可以提高数据检索效率，降低数据库的IO成本，通过索引列队数据进行排序，降低数据排序的成本，降低CPU的消耗。虽然索引大大提高了查询速度，但却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE（因为在更新表是，MySQL不仅要保存数据，还要调整索引信息）。索引本身也挺大，往往以索引文件的形式存储在磁盘上。聚集索引、复合索引、前缀索引、唯一索引默认使用B+树

单值索引：一个索引值包含单列，一个表可以有多个单列索引

组合索引：一个索引包含多列

唯一索引：索引列的值必须唯一，但允许有空值

主键索引：存储索引和数据，一种特殊的唯一索引，不允许有空值。一个表只能有一个主键

辅助索引：存储索引和主键

#### 索引类型

##### B+树索引

innodb默认的索引时B+树索索引，B+树索引并不能找到一个给定键值得具体行，B+数索引能找到的只是被查找数据行所在的页，然后数据库通过把页读入到内存中，再在内存中进行查找，最后得到要查找的数据

+ 二叉查找树：左子树的键值总是小于根的键值，右子树的键值总是大于根的键值（中序遍历可以得到键值的排序输出）在单链的时候二叉树的查询效率退化成O(n)
+ 平衡二叉树(AVL)：在二叉树的基础上满足”任何节点的两个子树的高度最大查为1“，查询效率为O(logn)，但维护平衡的代价是比较大的(需要多次左旋或右旋)

> 一般情况下，我们都会选择将user表中的数据和索引存储在磁盘这种外围设备中。但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，我们应当尽量**减少从磁盘中读取数据的次数。** **另外，从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。** 如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低。平衡二叉树每个节点只存储一个键值和数据的。如果我们用树这种数据结构作为索引的数据结构，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块。每个磁盘块仅仅存储一个键值和数据！那如果我们要存储海量的数据呢？可以想象到二叉树的节点将会非常多，高度也会及其高，我们查找数据时也会进行很多次磁盘IO，我们查找数据的效率将会极低！为了解决平衡二叉树的这个弊端，我们应该寻找一种单个节点可以存储多个键值和数据的平衡树。

+ 红黑树：

+ B树：B树的节点可以不止两个子节点，树变得又矮又胖，矮胖的树是索引的最爱，用它做索引可以降低磁盘的IO，B树中的每个节点根据实际情况可以包含大量的键值，数据和指针。在B树中每个节点的内容由三部分组成：键值，指针，数据，而磁盘块的容量是有限的，并不是每次读取磁盘块都会取出里面的数据，只是在最后一次读取的时候才会取出里面的数据。能不能将数据只存储在叶子节点里面，非叶子节点只存储键值和指针呢？这样就能最大化的利用磁盘块空间，一个磁盘块也就能存更多的东西了，没错，B+树就是这么干的

  > B树相对于平衡二叉树，每个节点存储了更多的键值(key)和数据(data)，并且每个节点拥有更多的子节点，子节点的个数一般称为阶，上述图中的B树为3阶B树，高度也会很低

+ B+树：在B+树中由于一个节点存储了更多的键值和指针，所以同样多的内容可以降低树的高度，减少磁盘io次数，从而提高效率。在B+树中因为叶子节点的键值是按顺序排列的所以进行键值的范围查找效率非常高。

  > 1. 非叶子节点只存储键值和指针。
  > 2. 所有叶子节点之间都有一个链指针。
  > 3. 数据记录都存放在叶子节点中。

B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，在B+树中，所有记录节点都是按键值得大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接。在数据库中，B+树的高度一般在2~4层，即查找某一键值得行记录时最多只需2到4次IO。当进行范围查找时，能通过叶子节点的指针获取数据。例如查找大于等于3的数据，当在叶子节点中查到3时，通过3的尾指针便能获取所有数据，而不需要再像二叉树一样再获取到3的父节点。数据库中的B+数索引可以分为聚集索引(clustered index)和辅助索引(secondary index)，两者的不同是叶子节点是否是一整行的信息。

+ 聚集索引：按每张表的的主键(主键可能是联合主键)构造一棵B+树，同时叶子节点中存放的即整张表的行记录数据，每个叶子节点通过一个双向链表进行链接。聚集索引的存储并不是物理上连续的，而是逻辑上连续的。每张InnoDB表有且只有一个聚集索引，聚簇索引保证关键字的值相近的元组存储的物理位置也相近（所以字符串类型不宜建立聚簇索引，特别是随机字符串，会使得系统进行大量的移动操作）
  + 如果我们定义了主键(PRIMARY KEY)，那么 InnoDB 会选择主键作为聚集索引。
  + 如果没有显式定义主键，则 InnoDB 会选择第一个不包含有 NULL 值的唯一索引作为主键索引。
  + 如果也没有这样的唯一索引，则 InnoDB 会选择内置 6 字节长的 ROWID 作为隐藏的聚集索引，它会随着行记录的写入而主键递增。
+ 辅助索引(非聚集索引)：叶子节点并不包含记录的全部数据，叶子节点除了本身的数据值以外，还包含该行数据的主键值。当通过辅助索引来寻找数据时，InnoDB会先遍历辅助索引找到叶子节点获取主键索引的键值，然后再通过主键索引到聚集索引查找相应的完整行数据。每个表可以有多个辅助索引，通常通过非主键索引比主键索引查找速度要慢一倍。

> show index from user\G    //查看user表的索引信息

Cardinality：表示索引中唯一值得数目估计值（优化器会根据该值来判断是否使用索引，但该值并不是实时更新的，即非每次索引的更新都会更新该值，但可以通过 analyze table user来更新，但 analyze table并不能保证正确，可能反而更加偏离实际值）

**B+树索引应用**

```
联合索引：对表上的多个列进行索引。例如联合索引(a,b)在叶子节点上顺序是根据(a,b)的,select * from user where a=xxx and order by b是可以直接通过联合索引得到结果的，因为b是排序的

覆盖索引：从辅助索引即可得到要查询的记录，而不需查询聚集索引的记录(即不需要回表)。使用覆盖索引的好处是辅助索引不包含整行的记录，其大小远小于聚集索引，可以减少大量IO操作。覆盖索引的另一个好处是统计，InnoDB一般不会选择通过查询聚集索引来进行统计，而是选择辅助索引查询统计(减少IO)，例如（a,b）的联合索引，一般直接选择b是不会走联合索引的，但select count(*) from user where b>1 and b<10则优化器会选择覆盖索引查询，即查找联合索引
EXPLAIN结果：possible_keys为null但key却使用到索引
```

FORCE INDEX(item_id_index)：强制使用某个索引

> select * from item_stock FORCE INDEX(item_id_index);

```
在某些情况下，优化器会不选择索引查找，而是通过聚集索引去查找（即全表扫描），这种情况多发生与范围查找。原因在于select * 选取的是整行信息，而辅助索引并不包含要查询的信息，即如果通过辅助索引查找指定数据后，还需要再次访问聚集索引来查找整行数据的信息，这导致要进行离散IO操作，则优化器会选择直接通过聚集索引来查找数据（顺序读要远远快于离散读），但如果要访问的数据量小时优化器还是会选择辅助索引的。因此对于不能进行索引覆盖的情况，优化器选择辅助索引的情况是：通过辅助索引查找的数据时少量的，但如果硬盘的随机读操作非常快，那么强制使用辅助索引有时可以提高更好的性能
```

![索引失效](..\image\索引失效.png)

![强制使用索引](..\image\强制使用索引.png)

![索引变更](..\image\索引变更.png)

##### hash索引

哈希索引基于哈希表实现，只有精确索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据的指针。检索效率高，一次定位，减少IO访问；仅仅使用于"="、“in”，不能使用范围索引（Memory表的默认索引类型）

> InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，但用户无法手动创建hash索引。从为数据记录建立索引来说，InnoDB引擎不支持hash索引，但是InnoDB会自调优(self-tuning)，在其内存结构中有一个自适应hash索引（key：索引键值或者键值前缀；value：索引记录页面位置），用于提高**查询索引**性能。自适应索引(Adaptive Hash Index)是InnoDB引擎的内存结构中的一种特性，当InnoDB注意到某些索引值被使用的非常频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-TREE索引也具有哈希索引的一些优点，比如快速的hash查找，这是一个完全自动的，内部的行为，用户无法控制或者配置，不过，对于某些工作负载，监视索引查找和维护哈希索引结构的额外开销远远超过了自适应哈希索引带来的性能提升，如果有必要，完全可以关闭该功能。

> show variables like '%innodb_adaptive_hash_index%'; //查看自适应索引情况

- 由于索引仅包含hash code和记录指针，所以，MySQL不能通过使用索引避免读取记录，即每次使用哈希索引查询到记录指针后都要回读元祖查取数据。
- 不能使用hash索引排序。
- Hash索引不支持键的部分匹配，因为是通过整个索引值来计算hash值的。
- Hash索引只支持等值比较，例如使用=，IN( )和<=>。对于WHERE price>100并不能加速查询。
- 访问Hash索引的速度非常快，除非有很多哈希冲突（不同的索引列值却有相同的哈希值）。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。
- 如果哈希冲突很多的话，一些索引维护操作的代价也会很高。当从表中删除一行时，存储引擎要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大。

##### FULLTEXT索引

只有char、varchar、text列才可以创建全文索引。MyISAM和InnoDB引擎都支持

> show variables like '%word%';   //查看fulltext参数
>
> show variables like '%ngram%';  //查看分词参数

>ALTER TABLE student ADD FULLTEXT INDEX  索引名(列名1，列名2) WITH PARSER NGRAM   //创建全文索引

> set global innodb_ft_aux_table='demo/student';    //显式指定全文检索的表源

> select * from information_schema.INNODB_FT_INDEX_TABLE;  //查看分词后的内容

> select count(*) FROM student WHERE MATCH(title,content) AGINST('学习' IN NATURAL LANGUAGE MODE)；//统计有多少行数据的（title，content）字段值包含‘学习’

> select * FROM student WHERE MATCH(title,content) AGINST('+学习 +设计' IN BOOLEAN MODE)   //查找同时包含‘学习’和‘设计’的记录

#### 索引失效

+ 不等于：<> 、!=

  ```
  应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。对于not in，可以用not exists或者（外联结+判断为空）来代替；很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num)
  
  对于<>，用其它相同功能的操作运算代替，如a<>0 改为 a>0 or a<0
  ```

+ 前导模糊查询：%xx%

  ```
  like语句不要以通配符开头
  ```

+ 比较不匹配的数据类型

  

+ or连接条件包含非索引列，即使全是索引列也可能没有使用索引

  ```
  用 or 分割开的条件， 如果 or 前的条件中的列有索引， 而后面的列中没有索引， 那么涉及到的索引都不会被用到。假设num1有索引，num2没有索引，查询语句select id from t where num1=10 or num2=20会放弃使用索引，可以改为这样查询： select id from t where num1=10 union all select id from t where num2=20，这样虽然num2没有使用索引，但至少num1会使用索引，提高效率。
  ```

+ 条件表达式前使用函数

  ```
  不要在列上进行运算
  ```

+ 隐式类型转换

  ```
  如果列类型是字符串，那么一定记得在 where 条件中把字符常量值用引号引起来
  ```

+ 联合索引违背最左前缀

  ```
  组合索引的使用要遵守“最左前缀”原则'，当不需要考虑排序和分组时，将选择性最高的列放在前面通常是最好的。
  ```

+ 避免覆盖索引失效

  ```
  任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段
  ```

#### 索引利弊

##### 优点

索引大大减小了服务器需要扫描的数据量
索引可以帮助服务器避免排序和临时表
索引可以将随机IO变成顺序IO

如果查询不能使用索引，MySQL会进行全表扫描，并锁住每一个元组，不管是否真正需要。
关于InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）

##### 缺点

虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存索引文件。
建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。
如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。
对于非常小的表，大部分情况下简单的全表扫描更高效；

MySQL里同一个数据表里的索引总数限制为16个。

#### 建索引的几大原则

1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

3.尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。

4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。

5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

### 性能优化

一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，所以查询语句的优化显然是重中之重。explain中的rows是核心指标，绝大部分rows小的语句执行一定很快（有例外）。所以优化语句基本上都是在优化rows。

#### 慢查询优化基本步骤

1. 先运行看看是否真的很慢，注意设置SQL_NO_CACHE
2. where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
3. explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）
4. order by limit 形式的sql语句让排序的表优先查
5. 了解业务方使用场景
6. 加索引时参照建索引的几大原则
7. 观察结果，不符合预期继续从0分析

#### 查询慢

+ SQL语句过于复杂，使用了多表关联查询（MySQL数据多表关联查询使用的笛卡尔积的形式，n*m）；如果查询时使用全表扫描会非常慢，特别是数据量大时查询慢效果很明显
+ 一次查询数据量大，返回不必要的字段数据，会导致查询慢，可能会提高死锁发生的概率(对于无用的大字段，如 varchar、blob、text，会增加 io 操作)

+ SQL没有建立合适的索引
+ SQL特定类型语句(COUNT、MAX、GROUP BY、LIMIT、UNION)使用不合理
+ 数据库表结构设计不合理，对表字段类型设计不合理
+ 数据库系统配置不合理、服务器硬件性能不足、网络慢

#### 慢查询日志

> show variables like 'slow_query%';  //查看慢查询是否开启以及慢查询日志存放路径
>
> set global slow_query_log='ON';   //开启慢查询
>
> show variables like 'long_query_time';  //查看多长时间为慢查询
>
> set profiling=1 //开启SQL语句执行时间统计
>
> show profiles  //查看SQL语句执行时间

#### 索引优化

尽量避免全表扫描（万级以上数据）；虽然索引提高查询速度，但维护的成本也高

+ 合适字段添加索引（where字段经常使用的字段）
  + 表之间的join键值上
+ 选择离散度大的字段建立联合索引，并把离散度最大的字段放在最前(值区分明显的字段)

> select  count(distinct id)/count(id)  from student;   //计算id字段的值离散度(越接近1离散度越高)

+ 合适长度的索引：综合考虑索引建立维护以及区分度

> ALTER TABLE student ADD INDEX  name5_index(name(4))  //指定使用name的前4建立索引

+ **使用索引覆盖**：如果查询范围是少量字段，可以考虑覆盖索引；避免从二级索引回表到主键索引数据表上查询数据
+ 前缀不易区分建立索引
+ 删除重复和冗余索引

#### 特定类型优化

> count(*)包括了所有的列，相当于行数，在统计结果的时候， 不会忽略列值为NULL 
> count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候， 不会忽略列值为NULL 
> count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数， 即某个字段值为NULL时，不统计

> 列名为主键，count(列名)会比count(1)快 
> 列名不为主键，count(1)会比count(列名)快 
> 如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*） 
> 如果有主键，则 select count（主键）的执行效率是最优的 
> 如果表只有一个字段，则 select count（*）最优。

+ count：如果某一字段经常需要统计，考虑给该字段添加索引，优先使用count(*)>count(1)>
+ max、min：如果某一字段经常需要获取最大值、最小值，考虑给该字段添加索引
+ group by：如果某一字段经常需要分组，考虑给该字段添加索引
+ limit：通过有索引的字段定位所查数据的位置

> select * from student limit 1000000,5   //获取1000000后5条记录，实际查询了10000005条记录

优化如下：先通过查询id分页找到数据所在的起始位置，然后通过id定位获取5条数据

> SELECT * FROM student  s1 INNER JOIN (select id from student limit 1000000,5) as s2 ON s1.id = s2.id

#### HANDLER_READ_*

MySQL到底是如何操作底层的数据?

> show status like ‘Handler_read%';

| **Handler_read_first**    | 表示全索引扫描的次数，当前者值较大，说明可能是一个全索引扫描,此外走全表也可能导致这个值比较大；后者表示在进行数据文件扫描时，从数据文件里取数据的次数。 |
| ------------------------- | ------------------------------------------------------------ |
| **Handler_read_rnd_next** | 该值的含义是数据文件中读下一行的请求数。如果正进行大量的表扫描， Handler_read_rnd_next 的值较高，则通常说明表索引不正确或写入的查询没有利用索引。当该值较大，说明扫描的行非常多，可能没有合理的使用索引，意味着查询运行低效 |
| **Handler_read_key**      | 表示走索引的次数，如果这个值比较大，说明索引使用良好         |



#### 数据库表优化

+ 字段数据类型选择：整型>date、time>emum、char>varchar>text > blob；整型数据是定长的，没有字符集差异；date、time日期类型数据定长、运算快、节省空间；enum枚举类型能起到约束作用，内部用整型存储；varchar字符串是变长数据类型，同时要考虑字符集和校对集；text、blob类型不能使用索引，也不能使用内存临时表。
+ 不常用字段分离：将不常使用到字段并且占用空间大的字段(text、blob)从原表中分离出来，独立建立另一个表
+ 适当添加冗余字段：在一个表中添加经常需要关联查询另一个表的字段；减少关联查询

#### 数据库配置优化

+ 内存使用参数
  + innodb_buffer_pool_size：Innodb存储引擎的缓冲池大小
  + innodb_buffer_pool_instances：缓冲池的个数
+ 日志控制参数
  + innodb_log_buffer_size：日志缓冲的大小
  + innodb_flush_log_at_trx_commit：0/1/2
  + innodb_log_file_size：指定事务日志的大小
  + innodb_log_files_in_group：指定日志组的个数
+ IO分配参数优化
  + innodb_file_per_table：独立表空间设置
  + innodb_file_io_threads：文件读取的线程个数
  + innodb_open_files：打开的文件个数
+ 其他参数
  + default-character-set：设置mysql客户端的字符集
  + character-set-server：设置mysql数据库的字符集

以下情况需要创建索引

1. 主键自动建立唯一索引
2. 频繁作为查询条件的字段应该创建索引
3. 查询中与其他表关联的字段，外键关系建立索引
4. 频繁更新的字段不适合创建
5. WHERE条件里用不到的字段不创建索引
6. 高并发下倾向创建组合索引

```
全值匹配我最爱，最左前缀要遵守
带头大哥不能死，中间兄弟不能死
索引列上少计算，范围之后全失效
LIKE百分写最右，覆盖索引不写*
不等空值还有or少用，会造成索引失效
```

**字符串类型数据的值在查询的时候一定要加单引号，否则可能会造成索引失效，导致行锁变为表锁**



##### 小表驱动大表

+ 当A表查询数据集大于B表查询数据集时，使用in

**select * from A where id in(select id from B)**  等价于

```
for select id from B
	for select * from A where A.id = B.id
```

+ 当A表查询数据集小于B表查询数据集时，使用exists

**select * from A where exists (select 1 from B where B.id = A.id)** 等价于

```
for select * from A
	for select * from B where B.id = A.id
```

### EXPLAIN

#### id

标识select语句的编号，有多select就会有多个id(有时id是一样的)，编号从1开始递增；代表执行顺序，值越大则优先级越高，值相同则从上而下执行

#### select_type

+ simple：简单查询，不包含子查询
+ primary：主查询，即最外层的select查询
+ subquery：子查询的第一个select查询，不依赖外部查询的结果集

> explain select * from item where id=(select id from item where id=2)

| id   | select_type | table |
| ---- | ----------- | ----- |
| 1    | PRIMARY     | item  |
| 2    | SUBQUERY    | item  |

+ union  && union result

> EXPLAIN select * from item where id=1 union select * from item where id=2

| id   | select_type  | table      |
| ---- | ------------ | ---------- |
| 1    | PRIMARY      | item       |
| 2    | UNION        | item       |
| NULL | UNION RESULT | (union1,2) |

+ dependent union && dependent subquery

> explain select * from item where id in (select id from item where id=2 union select id from item where id=3)

| id   | select_type       | table      |
| ---- | ----------------- | ---------- |
| 1    | PRIMARY           | item       |
| 2    | DEPENDENT SUQUERY | item       |
| 3    | DEPENDENT UNION   | item       |
| NULL | UNION RESULT      | (union2,3) |

#### table

查询所使用到的表名，可以是实际表名，也可以是别名

#### type

显示连接使用的类型，可以决定查询速度

+ null

+ system：表仅有一行
+ const：用于常数值比较PRIMARY KEY（当查询的表仅有一行时，使用system）

> explain select name from item **where id=1**  //id建立了唯一索引

+ eq_ref：相等引用查询，并且只能找到一行数据。常见于主键或唯一索引扫描的多表连接操作中

+ ref：引用查询，快速查找到多个符合条件的行(非唯一索引)
+ ref_or_nul：在初次查找的结果里找出null条目，然后进行二次查找
+ index_merge：索引合并优化被使用
+ unique_subquery：在某些IN查询中使用此类型，查询的是唯一索引
+ index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，查询的是非唯一索引
+ range：索引范围扫描，检索给定范围的索引行，常见于betwenn、<、>等查询

> explain select sales from item **where id>1**  //where条件处的id有建索引

+ index：全表扫描索引树的节点，只遍历索引树（即查询结果是在索引树上的）

> explain select **id** from item  //id建立了索引

+ all：从头到尾全表扫描，扫描全表数据（查询结果不是在索引树上找到的）

> explain select * from item
>
> explain select name from item  //name没有建索引
>
> explain select name from item  where age>20  //age没有建索引

#### possible_keys

可能用到的索引，如果为空说明没有可用的索引，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用

#### key

实际用到的索引，只能使用一个索引；如果为null，则没有使用索引

#### key_len

用到的索引长度，在不损失精确性的情况下，长度越短越好 

#### rows

扫描的行数

#### Extra

附加信息，查看索引使用情况

+ Using index：使用索引，没有查询数据表（即没有使用硬盘的数据表），只用索引表完成查询，也叫覆盖索引；如果同时出现Using where,说明使用索引查找记录，但需要查询到数据表

+ Using where：条件查询，不用读取表的所有数据或者通过索引就找到所需数据
+ Using filesort：文件排序（order by）
+ Using temporary：为了得到结果，使用了临时表

https://blog.csdn.net/u013308490/article/details/83001060