#### 1.JWT如何实现单点登录？

https://developer.51cto.com/art/202005/616622.htm

+ 传统session：当浏览器向服务器发送登录请求时，验证通过之后，会将用户信息存入seesion中，然后服务器会生成一个sessionId放入cookie中，随后返回给浏览器。当浏览器再次发送请求时，会在请求头部的cookie中放入sessionId，将请求数据一并发送给服务器。服务器就可以再次从seesion获取用户信息，整个流程完毕!同时，在服务端也可以通过seesion来判断当前用户是否已经登录，如果为空表示没有登录，直接跳转到登录页面;如果不为空，可以从session中获取用户信息即可进行后续操作。通常在服务端会设置seesion的时长，例如 30 分钟没有活动，会将已经存放的用户信息从seesion中移除。
+ token：将各个应用程序与内存数据库redis相连，对登录成功的用户信息进行一定的算法加密，生成的ID被称为token，将token还有用户的信息存入redis;等用户再次发起请求的时候，将token还有请求数据一并发送给服务器，服务端验证token是否存在redis中，如果存在，表示验证通过，如果不存在，告诉浏览器跳转到登录页面，流程结束。token方案保证了服务的无状态，所有的信息都是存在分布式缓存中。基于分布式存储，这样可以水平扩展来支持高并发。

```
JWT(JSON Web Token)是一个含签名并携带用户相关信息的加密串(JWT可以使用秘密（使用HMAC算法）或使用RSA或ECDSA的公钥/私钥对进行签名)，页面请求校验登录接口时，请求头中携带JWT串到后端服务，后端通过签名加密串匹配校验，保证信息未被篡改。校验通过则认为是可靠的请求，将正常返回数据。
```

JWT由三部分组成：头信息、有效负载、签名（xxx.yyy.zzz）

+ header：令牌类型(JWT)+散列算法(HMAC、RSASSA、RSASSA-PSS等)

> {  "alg": "HS256",  "typ": "JWT" }  //JSON会被编码为Base64Url

+ payload：有效信息，可存放用户数据。包含claims，claims是关于实体（常用的是用户信息）和其他数据的声明，claims有三种类型： registered(标准中的注册的声明), public(公共的声明), and private claims(私有的声明)。

标准中注册的声明 (建议但不强制使用)包括如下几个部分：

```
iss: jwt签发者;
sub: jwt所面向的用户;
aud: 接收jwt的一方;
exp: jwt的过期时间，这个过期时间必须要大于签发时间;
nbf: 定义在什么时间之前，该jwt都是不可用的;
iat: jwt的签发时间;
jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击;
```

> {
>   "sub": "1234567890",
>   "name": "John Doe",
>   "admin": true
> }

+ signature：采用编码的Header，编码的Payload，秘钥，Header中指定的算法，并对其进行签名。签名用于验证消息在此过程中未被篡改，并且，在使用私钥签名令牌的情况下，它还可以验证JWT的请求方是否是它所声明的请求方。(secret用来进行jwt的签发和jwt的验证，所以，在任何场景都不应该流露出去)

> HMACSHA256(  base64UrlEncode(header) + "." +  base64UrlEncode(payload),  secret)

头部、载荷的信息都可以通过base64解密出来，别在token中存放敏感信息



JWT白名单

```
在用户完成修改密码操作时. 将该用户加入到白名单中,先根据用户身份的唯一标识判断用户是否在白名单中,如果在,说明用户在token有效期内已经修改过一次密码, 现在就需要先删除用户白名单中的token数据,用户修改完密码后, 需要让用户重新进行登录生成新的access_token返回给客户端,调用生成token的工具生成access_token(访问token)的数据,判断用户是否有对应的白名单,如果有则将该token值存入到redis数据库的白名单中.当用户登录成功后,再进行用户认证,在验证token成功后, 对该用户的白名单进行验证,判断该用户是否在白名单中,如果在,则验证token是否在白名单中,如果在则允许用户访问,如果不在则不允许用户访问, 返回错误
```

JWT白名单

```
关于登录状态信息续签的问题。比如设置token的有效期为一个小时，那么一个小时后，如果用户仍然在这个web应用上，这个时候当然不能指望用户再登录一次。所以我们在每次用户发出请求的时候都返回一个新的token，前端再用这个新的token来替代旧的，这样每一次请求都会刷新token的有效期。但是这样，需要频繁的生成token。另外一种方案是使用Js来动态续签。判断还有多久这个token会过期，在
token快要过期时，返回一个新的token。用户主动注销，后台无法让用户强制下线。JWT并不支持用户主动退出登录，当然，可以在客户端删除这个token，但在别处使用的token仍然可以正常访问。为了支持注销和后台主动强制让用户下线， 我们在项目中的方案是在注销时将该token加入黑名单。当用户发出请求后，如果该token在黑名单中，则阻止用户的后续操作，返回Invalid token错误。对于名单的维护可以使用redis，token的过期时间和redis中数据的存活时间保持一致。
```

2. 定时刷新token？

https://blog.csdn.net/weixin_39954569/article/details/111802893

https://www.jianshu.com/p/16df5e53d89b

系统给用户 颁发 一个 token 无法实现，那么通过变通一个，给用户生成 2个 token ,一个用于 api 访问的 token ,一个 用于在 token 过期的时候 用来 刷新 的 refreshToken。并且 refreshToken 的 生命周期要比 token 的生命周期长。

用户登录系统的时候，后台给用户生成 token 和 refreshToken 并放在响应头中返回。系统 判断 token 是否合法：token 未失效的时的处理，token 失效 ,如何使用refreshToken来生成新的 token

3. 在退出登录 / 修改密码时怎样实现JWT Token失效？

```
将 token 存入 DB（如 Redis）中，失效则删除；但增加了一个每次校验时候都要先从 DB 中查询 token 是否存在的步骤，而且违背了 JWT 的无状态原则（这不就和 session 一样了么？）。
维护一个 token 黑名单，失效则加入黑名单中。
在 JWT 中增加一个版本号字段，失效则改变该版本号。
在服务端设置加密的 key 时，为每个用户生成唯一的 key，失效则改变该 key
```

登录比较简单，在验证身份信息后可以使用工具包例如jjwt根据用户信息生成token并设置有效时长，最后将token返回给客户端存储即可，客户端只需要每次访问时将token加在请求头里即可,然后在zuul增加一个filter,此filter来过滤请求，如果是登录获取token则放行，其他的话用公钥解密验证token是否有效。如果要实现刷新，则需要在生成token时生成一个refreshKey，在登录时和token一并返回给客户端，然后由客户端保存定时使用refreshKey和token来刷新获取新的有效时长的token,这个refreshKey可自定义生成，为了安全起见，服务器可能需要缓存refreshKey，可使用redis来进行存储，每次刷新token都将生成新的refreshKey和token，服务器需要将老refreshKey替换，客户端保存新的token和refreshKey来进行之后的访问和刷新。如果要实现注销，并使得旧的token即便在有效期内也不能通过验证，则需要修改登录、刷新、和优化zuul的filter。首先在登录时生成token和refreshKey后，需要将token也进行缓存，如果通过redis进行缓存可以直接放一个Set下，此Set存储所有未过期的token。其次，在刷新时在这个Set中删除旧的token并放入新的。最后对zuulFilter进行优化，在解密时先从redis里存放token的Set查找此token是否存在(redis的Set有提供方法)，如果没有则直接拒绝，如果有再进行下一步解密验证有效时长，验证有效时长是为了防止刷新机制失效、没有刷新机制、网络异常强行退出等事件出现，在这种情况下旧的token没有被删除，导致了旧的token一直可以访问(如果只验证是否token是否在缓存中)。在注销时只需要删除redis中Set的token记录就好，最后写个定时器去定时删除redis中Set里面过时的token,原因也是刷新机制失效、没有刷新机制、网络异常强行退出等事件出现导致旧的token没有被删除。

https://www.jianshu.com/p/0fd92ccc055e

#### 2.多线程安全问题的主要原因？

Java多线程与并发（二）https://v2as.com/article/9da51017-4474-4bef-99d2-689bdfa138d4

存在共享资源+多个线程竞争资源

解决：同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再对共享数据进行操作

Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成。

https://www.jianshu.com/p/4b6fbdf5a08f

CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有框架服务之后执行。CountDownLatch是通过一个计数器来实现的，计数器的初始化值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就相应得减1。当计数器到达0时，表示所有的线程都已完成任务，然后在闭锁上等待的线程就可以恢复执行任务。计数器count是闭锁需要等待的线程数量，只能被设置一次，且CountDownLatch没有提供任何机制去重新设置计数器count。

与CountDownLatch的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用CountDownLatch.await()方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。

其他N个线程必须引用CountDownLatch闭锁对象，因为它们需要通知CountDownLatch对象，它们各自完成了任务；这种通知机制是通过CountDownLatch.countDown()方法来完成的；每调用一次，count的值就减1，因此当N个线程都调用这个方法，count的值就等于0，然后主线程就可以通过await()方法，恢复执行自己的任务。

CountDownLatch在实时系统中的使用场景

1. 实现最大的并行性：有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数器为1的CountDownLatch，并让其他所有线程都在这个锁上等待，只需要调用一次countDown()方法就可以让其他所有等待的线程同时恢复执行。
2. 开始执行前等待N个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统都已经启动和运行了。
3. 死锁检测：一个非常方便的使用场景是你用N个线程去访问共享资源，在每个测试阶段线程数量不同，并尝试产生死锁。

#### 3.浏览器地址栏输入一个网址到显示网页发生了什么？

```
浏览器的地址栏输入URL并按下回车
浏览器查找当前URL是否存在缓存，并比较缓存是否过期
DNS解析:将域名解析成 IP 地址
TCP连接:TCP三次握手
发送 HTTP 请求
服务器处理请求并返回 HTTP 报文
浏览器解析渲染页面
断开连接：TCP 四次挥手
```

+ DNS解析

  + 用户输入url，例如http://[www.baidu.com](http://www.baidu.com/)。其中http为协议，[www.baidu.com](http://www.baidu.com/)为域名，域名并不是最后资源所在的真实位置，域名只是与IP地址的一个映射，使用域名是为了方便记忆，但是为了让计算机理解这个地址还需要把它解析为IP地址，所以要进行域名解析

    ```
    URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。比如 http://www.w3school.com.cn/ht...，遵守以下的语法规则：scheme://host.domain:port/path/filename
    ```

    + scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。
    + host，主机域名或IP地址
    + port，端口号（通常端口号不常见是因为大部分的都是使用默认的端口所以隐藏，如HTTP默认端口80，HTTPS默认端口443。
    + path，目录路径
    + filename - 定义文档/资源的名称

  + 域名解析： DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直至找到或到根节点。

    > 浏览器缓存 --> 操作系统缓存 --> 路由器缓存-->本地（ISP）域名服务器缓存 --> 根域名服务器

     （1）浏览器缓存：首先是查找浏览器缓存，浏览器会保存一段时间内访问过的一些网址的DNS信息，不同浏览器保存的时常不等。

    （2）操作系统缓存：如果没有找到对应的记录，这个时候浏览器会尝试调用操作系统缓存来继续查找这个网址的对应DNS信息。

    （3）路由缓存：如果还是没找到对应的IP，那么接着会发送一个请求到路由器上，然后路由器在自己的路由器缓存上查找记录，路由器一般也存有DNS信息。

    （4）ISP 的 DNS 服务器：如果还是没有，这个请求就会被发送到ISP（注：Internet Service Provider，互联网服务提供商，就是网络运营商，中国电信中国移动等），ISP也会有相应的ISP DNS服务器，就是本地DNS服务器，请求的域名基本上都能在这里找得到。

    （5）根服务器：如果还是没有的话， ISP的DNS服务器会将请求发向根域名服务器进行搜索。根域名服务器就是面向全球的顶级DNS服务器，共有13台逻辑上的服务器，从A到M命名，真正的实体服务器则有几百台，分布于全球各大洲。

    （6）如果到了这里还是找不到域名的对应信息，那只能说明一个问题：这个域名本来就不存在，它没有在网上正式注册过。或者域名过期了。

    ```
    DNS中递归查询和迭代查询的区别
    1、 递归查询： 一般客户机和服务器之间属递归查询，即当客户机向DNS服务器发出请求后，若DNS服务器本身不能解析，则会向另外的DNS服务器发出查询请求，得到结果后转交客户机。
    
    2、 迭代查询（反复查询）： 一般DNS服务器之间属迭代查询，如：若DNS2不能响应DNS1的请求，则它会将DNS3的IP给DNS2，以便其再向DNS3发出请求。
    ```

  + ```
    DNS中递归查询和迭代查询的区别
    1、 递归查询： 一般客户机和服务器之间属递归查询，即当客户机向DNS服务器发出请求后，若DNS服务器本身不能解析，则会向另外的DNS服务器发出查询请求，得到结果后转交客户机。
    
    2、 迭代查询（反复查询）： 一般DNS服务器之间属迭代查询，如：若DNS2不能响应DNS1的请求，则它会将DNS3的IP给DNS2，以便其再向DNS3发出请求。
    
    以一个DNS请求解析为例：
    
    1）用户发起域名请求到dnsA，这时dnsA有这个记录，将结果返回给用户，这个过程是递归查询。
    
    2）用户发起域名请求到dnsA，这时dns没有这个记录，它去向dnsB问有没有这个记录，以此类推，直到把结果返回给用户，这个过程是递归查询。
    
    3）用户发起域名请求到dnsA，这时dnsA没有这个记录，它告诉用户，我没有这个记录，你去问dnsB吧，这个过程是迭代查询。
    ```
  
+ HTTP请求：浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。接下来介绍向服务器发送 HTTP 请求阶段，HTTP 请求分为三个部分：TCP 三次握手、http 请求响应信息、关闭 TCP 连接。

  + 位于传输层的TCP协议为传输报文提供可靠的字节流服务。它为了方便传输，将大块的数据分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠，同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。**为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误**”。

    ```
    1.发送端先发送一个带有SYN（synchronize）标志的数据包给接收端，在一定的延迟时间内等待接收的回复。(SYN=1,Seq=X)
    2.接收端收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。(SYN=1,ACK=X+1,Seq=Y )
    3.接收方收到后再发送一个带有ACK标志的数据包给接收端以示握手成功(ACK=Y+1,Seq=Z)
    
    在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。
    ```

  + 应用层客户端发送HTTP请求，HTTP请求包括请求报头和请求主体两个部分，其中请求报头包含了至关重要的信息，包括请求的方法（GET / POST）、目标url、遵循的协议（http / https / ftp…），返回的信息是否需要缓存，以及客户端是否发送cookie等

    请求报文由请求行（request line）、请求头（header）、请求体三个部分组成：

    + 请求行包含请求方法、URL、协议版本

      + 请求方法:GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE
      + URL即请求地址：<协议>：//<主机>：<端口>/<路径>?<参数> 
      +  http 版本号

      > POST /chapter17/user.html HTTP/1.1POST”代表请求方法，“/chapter17/user.html”表示 URL，“HTTP/1.1”代表协议和协议的版本。现在比较流行的是 Http1.1 版本

    + 请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔

      > 请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如：**Host，表示主机名，虚拟主机；Connection,HTTP/1.1 增加的，使用 keepalive，即持久连接，一个连接可以发多个请求；User-Agent，请求发出者，兼容性以及定制化需求。**

    + 请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据

      > name=tom&password=1234&realName=tomson

  

+ ARP/RAP寻址：IP协议的作用是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。在找到对方的MAC地址后，就将数据发送到数据链路层传输。这时，客户端发送请求的阶段结束

+ HTTP响应：服务接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文。通常客户端首次访问服务器，服务端返回响应时通过附带一个记录的客户端信息的标识来返回给客户端，这个标识就是JSESSIONID，JSESSIONID就放在了客户端的Cookies里。当客户端再次向服务器发送请求时上就使用上次记录的Cookies里面的JSESSIONID。

  + 响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成

    + 响应行包含：协议版本，状态码，状态码描述

      > 1xx：指示信息--表示请求已接收，继续处理。
      >
      > 2xx：成功--表示请求已被成功接收、理解、接受。
      >
      > 3xx：重定向--要完成请求必须进行更进一步的操作。
      >
      > 4xx：客户端错误--请求有语法错误或请求无法实现。
      >
      > 5xx：服务器端错误--服务器未能实现合法的请求。

    + 响应头部包含响应报文的附加信息，由 名/值 对组成

    + 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据


+ 页面渲染：根据 HTML 解析出 DOM 树、根据 CSS 解析生成 CSS 规则树、结合 DOM 树和 CSS 规则树，生成渲染树、根据渲染树计算每一个节点的信息、根据计算好的信息绘制页面

     ```
       DOM树是由HTML文件中的标签排列组成，渲染树是在DOM树中加入CSS或HTML中的style样式而形成。渲染树只包含需要显示在页面中的DOM元素，像<head>元素或display属性值为none的元素都不在渲染树中。
     
       在浏览器还没接收到完整的HTML文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送HTTP请求重复上述的步骤。在收到CSS文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。
     ```

+ 关闭连接：当数据完成请求到返回的过程之后，根据Connection的Keep-Alive属性可以选择是否断开TCP连接，HTTP/1.1一般支持同一个TCP多个请求，而不是1.0版本下的完成一次请求就发生断开。TCP的断开与连接不一样，断开可以分为主动关闭和被动关闭，需要经过4次握手。



