#### 提高查找mysql查询速度

+ 原因
  + SQL语句写不好
  + 没有建立索引、索引不合理、索引失效
  + 关联查询太多
  + 服务器磁盘你空间不足
  + 服务调优配置参数设置不合理

+ 解决方案

  + 使用索引

  + 选取最合适的字段属性：**表中字段的宽度尽可能设小**，例如手机号一般为11位就设为char(11)，不需要设为char(255)；**尽量将字段设置为NOT NULL**，这样数据库在查询的时候不用去比较null值；**特别字段使用ENUM型**，在MySQL中，ENUM类型被当做数值型数据来处理，而数值型数据处理起来的速度要比文本类型快得多

  + 使用连接(JOIN)来代替子查询(Sub-Queries)：

  + 小表驱动大表：MySQL 表关联的算法是 Nest Loop Join，是通过驱动表的结果集作为循环基础数据，然后一条一条地通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果

    ```
    user表10000条数据，class表20条数据
    select * from user u left join class c u.userid=c.userid
    
    这样则需要用user表循环10000次才能查询出来，而如果用class表驱动user表则只需要循环20次就能查询出来例：
    select * from class c left join user u c.userid=u.userid
    ```

#### char与varchar的区别

+ 长度：char的长度是固定不变，varchar的长度可变。定义一个CHAR(10)和VARCHAR(10),如果存进去的是‘ABCD’, 那么CHAR所占的长度依然为10，除了字符‘ABCD’外，后面跟六个空格，而VARCHAR的长度变为4了，取数据的时候，CHAR类型的要用trim()去掉多余的空格，而VARCHAR类型是不需要的
+ 存取速度：char的存取速度要比varchar快很多。char的长度是固定的，虽然可能会造成空间浪费，但方便程序的存储与查询；而varchar则以空间效率为首位
+ 存储方式：在char中，一个英文字符(ASCII)占用1个字节，一个汉字占有两个字节；而在varchar中，一个英文字符占用2个字节，一个汉字也占用2个字节

#### 表锁与行锁

在操作数据库的时候，可能会由于并发问题而引起的数据的不一致性（数据冲突）。如何保证数据并发访问的一致性、有效性，是所有数据库必须解决的一个问题，锁的冲突也是影响数据库并发访问性能的一个重要因素，从这一角度来说，锁对于数据库而言就显得尤为重要。

> MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）

> InnoDB存储引擎既支持行级锁（ row-level locking），也支持表级锁，但默认情况下是采用行级锁

+ 行锁：访问数据库的时候，锁定整个行数据，防止并发错误。开销小，加锁快，不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低

+ 表锁：访问数据库的时候，锁定整个表数据，防止并发错误。开销大，加锁慢，会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高

#### 乐观锁与悲观锁

+ 乐观锁：以一种悲观的态度去获取数据，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁

  > 传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁

+ 悲观锁：以一种乐观的态度去获取数据，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制

  > 乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁

+ 区别：**乐观锁适用于写比较少的情况下**，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。**如果经常产生冲突**，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适

#### 跳表

利用局部数据，一层一层靠近查询数据

![跳表](..\image\跳表.jpg)

